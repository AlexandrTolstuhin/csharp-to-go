# 1.4 –ü—Ä–∞–∫—Ç–∏–∫–∞: –ó–∞–∫—Ä–µ–ø–ª–µ–Ω–∏–µ –æ—Å–Ω–æ–≤

## –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ
- [–í–≤–µ–¥–µ–Ω–∏–µ](#–≤–≤–µ–¥–µ–Ω–∏–µ)
- [–ü—Ä–æ–µ–∫—Ç 1: CLI-—É—Ç–∏–ª–∏—Ç–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–∞–º–∏](#–ø—Ä–æ–µ–∫—Ç-1-cli-—É—Ç–∏–ª–∏—Ç–∞-–¥–ª—è-—Ä–∞–±–æ—Ç—ã-—Å-—Ñ–∞–π–ª–∞–º–∏)
- [–ü—Ä–æ–µ–∫—Ç 2: HTTP-—Å–µ—Ä–≤–µ—Ä —Å JSON API](#–ø—Ä–æ–µ–∫—Ç-2-http-—Å–µ—Ä–≤–µ—Ä-—Å-json-api)
- [–ü—Ä–æ–µ–∫—Ç 3: –ö–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö](#–ø—Ä–æ–µ–∫—Ç-3-–∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–∞—è-–æ–±—Ä–∞–±–æ—Ç–∫–∞-–¥–∞–Ω–Ω—ã—Ö)
- [–ü—Ä–æ–µ–∫—Ç 4: –ü–∞—Ä—Å–µ—Ä –ª–æ–≥–æ–≤](#–ø—Ä–æ–µ–∫—Ç-4-–ø–∞—Ä—Å–µ—Ä-–ª–æ–≥–æ–≤)
- [–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∑–∞–¥–∞—á–∏](#–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ-–∑–∞–¥–∞—á–∏)
- [–†–µ—à–µ–Ω–∏—è –∏ –ø–æ–¥—Å–∫–∞–∑–∫–∏](#—Ä–µ—à–µ–Ω–∏—è-–∏-–ø–æ–¥—Å–∫–∞–∑–∫–∏)

---

## –í–≤–µ–¥–µ–Ω–∏–µ

–í —ç—Ç–æ–º —Ä–∞–∑–¥–µ–ª–µ –≤—ã –∑–∞–∫—Ä–µ–ø–∏—Ç–µ –±–∞–∑–æ–≤—ã–µ –∑–Ω–∞–Ω–∏—è Go —á–µ—Ä–µ–∑ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–µ–∫—Ç—ã. –ö–∞–∂–¥—ã–π –ø—Ä–æ–µ–∫—Ç —Ä–∞–∑–±–∏—Ç –Ω–∞ —ç—Ç–∞–ø—ã —Å –ø–æ–¥—Å–∫–∞–∑–∫–∞–º–∏ –∏ —Ä–µ—à–µ–Ω–∏—è–º–∏.

### –ß—Ç–æ –≤—ã –æ—Ç—Ä–∞–±–æ—Ç–∞–µ—Ç–µ

- ‚úÖ –†–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–æ–π
- ‚úÖ CLI –∞—Ä–≥—É–º–µ–Ω—Ç—ã –∏ —Ñ–ª–∞–≥–∏
- ‚úÖ HTTP —Å–µ—Ä–≤–µ—Ä—ã –∏ —Ä–æ—É—Ç–∏–Ω–≥
- ‚úÖ JSON —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è/–¥–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è
- ‚úÖ Error handling
- ‚úÖ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
- ‚úÖ Goroutines –∏ channels
- ‚úÖ –†–∞–±–æ—Ç–∞ —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º

### –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è

–ü–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º —É–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –ø—Ä–æ—à–ª–∏:
- [01_setup_environment.md](01_setup_environment.md)
- [02_syntax_basics.md](02_syntax_basics.md)
- [03_key_differences.md](03_key_differences.md)

---

## –ü—Ä–æ–µ–∫—Ç 1: CLI-—É—Ç–∏–ª–∏—Ç–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–∞–º–∏

### –û–ø–∏—Å–∞–Ω–∏–µ

–°–æ–∑–¥–∞–π—Ç–µ —É—Ç–∏–ª–∏—Ç—É `filetools` –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–∞–º–∏ –∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è–º–∏. –≠—Ç–æ –∞–Ω–∞–ª–æ–≥ –±–∞–∑–æ–≤—ã—Ö UNIX-–∫–æ–º–∞–Ω–¥.

### –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å

```bash
# –ü–æ–¥—Å—á—ë—Ç —Å—Ç—Ä–æ–∫ –≤ —Ñ–∞–π–ª–µ
filetools count lines file.txt

# –ü–æ–¥—Å—á—ë—Ç —Å–ª–æ–≤
filetools count words file.txt

# –ü–æ–∏—Å–∫ —Ç–µ–∫—Å—Ç–∞ –≤ —Ñ–∞–π–ª–∞—Ö
filetools search "pattern" *.txt

# –í—ã–≤–æ–¥ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ (–∫–∞–∫ tree)
filetools tree ./src

# –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ —Å –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–æ–º
filetools copy source.bin dest.bin

# –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ö–µ—à–∞ —Ñ–∞–π–ª–∞ (MD5, SHA256)
filetools hash sha256 file.bin
```

### –≠—Ç–∞–ø 1: –ü–æ–¥—Å—á—ë—Ç —Å—Ç—Ä–æ–∫ –∏ —Å–ª–æ–≤

**–ó–∞–¥–∞—á–∞**: –†–µ–∞–ª–∏–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É `count lines` –∏ `count words`.

**–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è**:
- –ß–∏—Ç–∞–π—Ç–µ —Ñ–∞–π–ª –ø–æ—Å—Ç—Ä–æ—á–Ω–æ (–Ω–µ –∑–∞–≥—Ä—É–∂–∞–π—Ç–µ –≤–µ—Å—å —Ñ–∞–π–ª –≤ –ø–∞–º—è—Ç—å)
- –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–π—Ç–µ –æ—à–∏–±–∫–∏ (—Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–µ—Ç –ø—Ä–∞–≤ –∏ —Ç.–¥.)
- –ü–æ–¥–¥–µ—Ä–∂–∏—Ç–µ —Ñ–ª–∞–≥ `--verbose` –¥–ª—è –≤—ã–≤–æ–¥–∞ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏

**–ü–æ–¥—Å–∫–∞–∑–∫–∞**:
```go
package main

import (
    "bufio"
    "flag"
    "fmt"
    "os"
    "strings"
)

func countLines(filename string) (int, error) {
    // TODO: –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª
    // TODO: —Å–æ–∑–¥–∞—Ç—å bufio.Scanner
    // TODO: –ø–æ–¥—Å—á–∏—Ç–∞—Ç—å —Å—Ç—Ä–æ–∫–∏
    return 0, nil
}

func countWords(filename string) (int, error) {
    // TODO: –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ countLines, –Ω–æ —Å—á–∏—Ç–∞–µ–º —Å–ª–æ–≤–∞
    // –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ strings.Fields() –¥–ª—è —Ä–∞–∑–±–∏–µ–Ω–∏—è —Å—Ç—Ä–æ–∫–∏
    return 0, nil
}

func main() {
    // TODO: –ø–∞—Ä—Å–∏–Ω–≥ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
    // TODO: –≤—ã–∑–æ–≤ –Ω—É–∂–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
}
```

**–ü—Ä–æ–≤–µ—Ä–∫–∞**:
```bash
go run main.go count lines test.txt
# Lines: 42

go run main.go count words test.txt
# Words: 256
```

<details>
<summary>üìñ –†–µ—à–µ–Ω–∏–µ —ç—Ç–∞–ø–∞ 1</summary>

```go
package main

import (
    "bufio"
    "flag"
    "fmt"
    "os"
    "strings"
)

func countLines(filename string, verbose bool) (int, error) {
    file, err := os.Open(filename)
    if err != nil {
        return 0, fmt.Errorf("open file: %w", err)
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    count := 0

    for scanner.Scan() {
        count++
        if verbose && count%1000 == 0 {
            fmt.Printf("Processed %d lines...\n", count)
        }
    }

    if err := scanner.Err(); err != nil {
        return count, fmt.Errorf("scan file: %w", err)
    }

    return count, nil
}

func countWords(filename string, verbose bool) (int, error) {
    file, err := os.Open(filename)
    if err != nil {
        return 0, fmt.Errorf("open file: %w", err)
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    count := 0

    for scanner.Scan() {
        line := scanner.Text()
        words := strings.Fields(line)
        count += len(words)
    }

    if err := scanner.Err(); err != nil {
        return count, fmt.Errorf("scan file: %w", err)
    }

    return count, nil
}

func main() {
    if len(os.Args) < 3 {
        fmt.Println("Usage: filetools count [lines|words] <filename>")
        os.Exit(1)
    }

    verbose := flag.Bool("verbose", false, "verbose output")
    flag.CommandLine.Parse(os.Args[3:])

    command := os.Args[1]
    subcommand := os.Args[2]
    filename := flag.Arg(0)

    if command != "count" {
        fmt.Printf("Unknown command: %s\n", command)
        os.Exit(1)
    }

    var count int
    var err error

    switch subcommand {
    case "lines":
        count, err = countLines(filename, *verbose)
    case "words":
        count, err = countWords(filename, *verbose)
    default:
        fmt.Printf("Unknown subcommand: %s\n", subcommand)
        os.Exit(1)
    }

    if err != nil {
        fmt.Printf("Error: %v\n", err)
        os.Exit(1)
    }

    fmt.Printf("%s: %d\n", strings.Title(subcommand), count)
}
```
</details>

### –≠—Ç–∞–ø 2: –ü–æ–∏—Å–∫ —Ç–µ–∫—Å—Ç–∞ –≤ —Ñ–∞–π–ª–∞—Ö (grep)

**–ó–∞–¥–∞—á–∞**: –†–µ–∞–ª–∏–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É `search` –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–∞—Ç—Ç–µ—Ä–Ω–∞ –≤ —Ñ–∞–π–ª–∞—Ö.

**–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è**:
- –ü–æ–¥–¥–µ—Ä–∂–∏—Ç–µ wildcard –ø–∞—Ç—Ç–µ—Ä–Ω—ã (`*.txt`)
- –í—ã–≤–æ–¥–∏—Ç–µ –∏–º—è —Ñ–∞–π–ª–∞, –Ω–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏ –∏ —Å–∞–º—É —Å—Ç—Ä–æ–∫—É
- –ü–æ–¥–¥–µ—Ä–∂–∏—Ç–µ —Ñ–ª–∞–≥ `--ignore-case` –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–æ–Ω–µ–∑–∞–≤–∏—Å–∏–º–æ–≥–æ –ø–æ–∏—Å–∫–∞
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ regexp –¥–ª—è –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤

**–ü–æ–¥—Å–∫–∞–∑–∫–∞**:
```go
import (
    "path/filepath"
    "regexp"
)

func searchInFile(filename, pattern string, ignoreCase bool) error {
    // TODO: –æ—Ç–∫—Ä–æ–π—Ç–µ —Ñ–∞–π–ª
    // TODO: —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–π—Ç–µ regexp
    // TODO: –∏—â–∏—Ç–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –ø–æ—Å—Ç—Ä–æ—á–Ω–æ
    // TODO: –≤—ã–≤–æ–¥–∏—Ç–µ filename:lineNum:line
    return nil
}

func main() {
    // TODO: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ filepath.Glob –¥–ª—è wildcard
    // –ü—Ä–∏–º–µ—Ä: matches, err := filepath.Glob("*.txt")
}
```

<details>
<summary>üìñ –†–µ—à–µ–Ω–∏–µ —ç—Ç–∞–ø–∞ 2</summary>

```go
func searchInFile(filename, pattern string, ignoreCase bool) error {
    file, err := os.Open(filename)
    if err != nil {
        return fmt.Errorf("open file: %w", err)
    }
    defer file.Close()

    // –ö–æ–º–ø–∏–ª–∏—Ä—É–µ–º —Ä–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ
    var re *regexp.Regexp
    if ignoreCase {
        re, err = regexp.Compile("(?i)" + pattern)
    } else {
        re, err = regexp.Compile(pattern)
    }
    if err != nil {
        return fmt.Errorf("compile regex: %w", err)
    }

    scanner := bufio.NewScanner(file)
    lineNum := 0

    for scanner.Scan() {
        lineNum++
        line := scanner.Text()

        if re.MatchString(line) {
            // –í—ã–≤–æ–¥–∏–º –≤ —Ñ–æ—Ä–º–∞—Ç–µ grep: filename:lineNum:line
            fmt.Printf("%s:%d:%s\n", filename, lineNum, line)
        }
    }

    return scanner.Err()
}

func searchCommand(pattern string, filePattern string, ignoreCase bool) error {
    matches, err := filepath.Glob(filePattern)
    if err != nil {
        return fmt.Errorf("glob pattern: %w", err)
    }

    if len(matches) == 0 {
        return fmt.Errorf("no files match pattern: %s", filePattern)
    }

    for _, filename := range matches {
        if err := searchInFile(filename, pattern, ignoreCase); err != nil {
            fmt.Fprintf(os.Stderr, "Error searching %s: %v\n", filename, err)
        }
    }

    return nil
}
```
</details>

### –≠—Ç–∞–ø 3: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ö–µ—à–µ–π

**–ó–∞–¥–∞—á–∞**: –†–µ–∞–ª–∏–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É `hash` –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è MD5/SHA256 —Ö–µ—à–∞ —Ñ–∞–π–ª–∞.

**–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è**:
- –ü–æ–¥–¥–µ—Ä–∂–∏—Ç–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã: md5, sha1, sha256
- –ß–∏—Ç–∞–π—Ç–µ —Ñ–∞–π–ª –±–ª–æ–∫–∞–º–∏ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –ø–∞–º—è—Ç–∏
- –í—ã–≤–æ–¥–∏—Ç–µ —Ö–µ—à –≤ hex —Ñ–æ—Ä–º–∞—Ç–µ

**–ü—Ä–æ–≤–µ—Ä–∫–∞**:
```bash
go run main.go hash sha256 file.bin
# SHA256: a1b2c3d4...
```

<details>
<summary>üìñ –†–µ—à–µ–Ω–∏–µ —ç—Ç–∞–ø–∞ 3</summary>

```go
import (
    "crypto/md5"
    "crypto/sha1"
    "crypto/sha256"
    "encoding/hex"
    "hash"
    "io"
)

func hashFile(filename, algorithm string) (string, error) {
    file, err := os.Open(filename)
    if err != nil {
        return "", fmt.Errorf("open file: %w", err)
    }
    defer file.Close()

    var hasher hash.Hash

    switch algorithm {
    case "md5":
        hasher = md5.New()
    case "sha1":
        hasher = sha1.New()
    case "sha256":
        hasher = sha256.New()
    default:
        return "", fmt.Errorf("unsupported algorithm: %s", algorithm)
    }

    // –ö–æ–ø–∏—Ä—É–µ–º —Ñ–∞–π–ª –≤ hasher –±–ª–æ–∫–∞–º–∏
    if _, err := io.Copy(hasher, file); err != nil {
        return "", fmt.Errorf("hash file: %w", err)
    }

    hashBytes := hasher.Sum(nil)
    return hex.EncodeToString(hashBytes), nil
}
```
</details>

### –ü–æ–ª–Ω—ã–π –∫–æ–¥ –ø—Ä–æ–µ–∫—Ç–∞

–ü–æ—Å–ª–µ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –≤—Å–µ—Ö —ç—Ç–∞–ø–æ–≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞:

```
filetools/
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ commands/
‚îÇ   ‚îú‚îÄ‚îÄ count.go
‚îÇ   ‚îú‚îÄ‚îÄ search.go
‚îÇ   ‚îî‚îÄ‚îÄ hash.go
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îî‚îÄ‚îÄ file.go
‚îî‚îÄ‚îÄ main_test.go
```

### –ó–∞–¥–∞–Ω–∏—è –¥–ª—è —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ–π —Ä–∞–±–æ—Ç—ã

1. –î–æ–±–∞–≤—å—Ç–µ –∫–æ–º–∞–Ω–¥—É `tree` –¥–ª—è –≤—ã–≤–æ–¥–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
2. –†–µ–∞–ª–∏–∑—É–π—Ç–µ `copy` —Å –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–æ–º (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ goroutine)
3. –î–æ–±–∞–≤—å—Ç–µ –ø–æ–¥–¥–µ—Ä–∂–∫—É `.gitignore` –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ –≤ `search`
4. –ù–∞–ø–∏—à–∏—Ç–µ unit-—Ç–µ—Å—Ç—ã –¥–ª—è –≤—Å–µ—Ö –∫–æ–º–∞–Ω–¥
5. –°–æ–±–µ—Ä–∏—Ç–µ –±–∏–Ω–∞—Ä–Ω–∏–∫ —Å –ø–æ–º–æ—â—å—é `go build` –∏ –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –µ–≥–æ —Ä–∞–∑–º–µ—Ä

---

## –ü—Ä–æ–µ–∫—Ç 2: HTTP-—Å–µ—Ä–≤–µ—Ä —Å JSON API

### –û–ø–∏—Å–∞–Ω–∏–µ

–°–æ–∑–¥–∞–π—Ç–µ RESTful API –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∞–º–∏ (TODO list). –≠—Ç–æ —Ç–∏–ø–∏—á–Ω—ã–π CRUD-—Å–µ—Ä–≤–∏—Å.

### API —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è

```
GET    /api/tasks           - –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∑–∞–¥–∞—á–∏
GET    /api/tasks/:id       - –ü–æ–ª—É—á–∏—Ç—å –∑–∞–¥–∞—á—É –ø–æ ID
POST   /api/tasks           - –°–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É
PUT    /api/tasks/:id       - –û–±–Ω–æ–≤–∏—Ç—å –∑–∞–¥–∞—á—É
DELETE /api/tasks/:id       - –£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É
GET    /health              - Health check
```

### –ú–æ–¥–µ–ª—å –¥–∞–Ω–Ω—ã—Ö

```go
type Task struct {
    ID          int       `json:"id"`
    Title       string    `json:"title"`
    Description string    `json:"description"`
    Completed   bool      `json:"completed"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}
```

### –≠—Ç–∞–ø 1: –ë–∞–∑–æ–≤—ã–π HTTP —Å–µ—Ä–≤–µ—Ä

**–ó–∞–¥–∞—á–∞**: –°–æ–∑–¥–∞–π—Ç–µ HTTP —Å–µ—Ä–≤–µ—Ä —Å —Ä–æ—É—Ç–∏–Ω–≥–æ–º.

**–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è**:
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π `net/http` (–±–µ–∑ —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–æ–≤)
- –†–µ–∞–ª–∏–∑—É–π—Ç–µ health check endpoint
- –õ–æ–≥–∏—Ä—É–π—Ç–µ –≤—Å–µ –∑–∞–ø—Ä–æ—Å—ã
- Graceful shutdown

**–ü–æ–¥—Å–∫–∞–∑–∫–∞**:
```go
package main

import (
    "context"
    "encoding/json"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func healthHandler(w http.ResponseWriter, r *http.Request) {
    // TODO: –≤–µ—Ä–Ω–∏—Ç–µ {"status": "ok"}
}

func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        // TODO: –ª–æ–≥–∏—Ä—É–π—Ç–µ –º–µ—Ç–æ–¥, –ø—É—Ç—å, –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
        next.ServeHTTP(w, r)
        log.Printf("%s %s - %v", r.Method, r.URL.Path, time.Since(start))
    })
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/health", healthHandler)

    // –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º –≤ middleware
    handler := loggingMiddleware(mux)

    srv := &http.Server{
        Addr:         ":8080",
        Handler:      handler,
        ReadTimeout:  10 * time.Second,
        WriteTimeout: 10 * time.Second,
    }

    // TODO: –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞ –≤ goroutine
    // TODO: graceful shutdown –ø–æ —Å–∏–≥–Ω–∞–ª—É
}
```

<details>
<summary>üìñ –†–µ—à–µ–Ω–∏–µ —ç—Ç–∞–ø–∞ 1</summary>

```go
package main

import (
    "context"
    "encoding/json"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func healthHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]string{
        "status": "ok",
        "time":   time.Now().Format(time.RFC3339),
    })
}

func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        next.ServeHTTP(w, r)
        log.Printf("%s %s - %v", r.Method, r.URL.Path, time.Since(start))
    })
}

func main() {
    mux := http.NewServeMux()
    mux.HandleFunc("/health", healthHandler)

    handler := loggingMiddleware(mux)

    srv := &http.Server{
        Addr:         ":8080",
        Handler:      handler,
        ReadTimeout:  10 * time.Second,
        WriteTimeout: 10 * time.Second,
        IdleTimeout:  60 * time.Second,
    }

    // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–µ—Ä –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π goroutine
    go func() {
        log.Printf("Starting server on %s", srv.Addr)
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("Server failed: %v", err)
        }
    }()

    // Graceful shutdown
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit

    log.Println("Shutting down server...")

    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    if err := srv.Shutdown(ctx); err != nil {
        log.Fatalf("Server forced to shutdown: %v", err)
    }

    log.Println("Server stopped")
}
```
</details>

### –≠—Ç–∞–ø 2: In-memory —Ö—Ä–∞–Ω–∏–ª–∏—â–µ

**–ó–∞–¥–∞—á–∞**: –†–µ–∞–ª–∏–∑—É–π—Ç–µ CRUD –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å —Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –≤ –ø–∞–º—è—Ç–∏.

**–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è**:
- Thread-safe –æ–ø–µ—Ä–∞—Ü–∏–∏ (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ `sync.RWMutex`)
- –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- –ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ HTTP –∫–æ–¥—ã –æ—Ç–≤–µ—Ç–æ–≤
- –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫

**–ü–æ–¥—Å–∫–∞–∑–∫–∞**:
```go
type TaskStore struct {
    mu    sync.RWMutex
    tasks map[int]*Task
    nextID int
}

func NewTaskStore() *TaskStore {
    return &TaskStore{
        tasks: make(map[int]*Task),
        nextID: 1,
    }
}

func (s *TaskStore) Create(task *Task) (*Task, error) {
    s.mu.Lock()
    defer s.mu.Unlock()

    // TODO: –≤–∞–ª–∏–¥–∞—Ü–∏—è
    // TODO: —É—Å—Ç–∞–Ω–æ–≤–∫–∞ ID, timestamps
    // TODO: —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ map

    return task, nil
}

func (s *TaskStore) GetAll() []*Task {
    // TODO: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ s.mu.RLock()
    return nil
}

func (s *TaskStore) GetByID(id int) (*Task, error) {
    // TODO: —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ
    return nil, nil
}

func (s *TaskStore) Update(id int, task *Task) (*Task, error) {
    // TODO: —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ
    return nil, nil
}

func (s *TaskStore) Delete(id int) error {
    // TODO: —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ
    return nil
}
```

<details>
<summary>üìñ –†–µ—à–µ–Ω–∏–µ —ç—Ç–∞–ø–∞ 2</summary>

```go
import (
    "errors"
    "sync"
    "time"
)

var (
    ErrTaskNotFound = errors.New("task not found")
    ErrInvalidTask  = errors.New("invalid task")
)

type Task struct {
    ID          int       `json:"id"`
    Title       string    `json:"title"`
    Description string    `json:"description"`
    Completed   bool      `json:"completed"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}

type TaskStore struct {
    mu     sync.RWMutex
    tasks  map[int]*Task
    nextID int
}

func NewTaskStore() *TaskStore {
    return &TaskStore{
        tasks:  make(map[int]*Task),
        nextID: 1,
    }
}

func (s *TaskStore) Create(task *Task) (*Task, error) {
    if task.Title == "" {
        return nil, ErrInvalidTask
    }

    s.mu.Lock()
    defer s.mu.Unlock()

    now := time.Now()
    task.ID = s.nextID
    s.nextID++
    task.CreatedAt = now
    task.UpdatedAt = now

    s.tasks[task.ID] = task

    return task, nil
}

func (s *TaskStore) GetAll() []*Task {
    s.mu.RLock()
    defer s.mu.RUnlock()

    tasks := make([]*Task, 0, len(s.tasks))
    for _, task := range s.tasks {
        tasks = append(tasks, task)
    }

    return tasks
}

func (s *TaskStore) GetByID(id int) (*Task, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    task, exists := s.tasks[id]
    if !exists {
        return nil, ErrTaskNotFound
    }

    return task, nil
}

func (s *TaskStore) Update(id int, updatedTask *Task) (*Task, error) {
    if updatedTask.Title == "" {
        return nil, ErrInvalidTask
    }

    s.mu.Lock()
    defer s.mu.Unlock()

    task, exists := s.tasks[id]
    if !exists {
        return nil, ErrTaskNotFound
    }

    task.Title = updatedTask.Title
    task.Description = updatedTask.Description
    task.Completed = updatedTask.Completed
    task.UpdatedAt = time.Now()

    return task, nil
}

func (s *TaskStore) Delete(id int) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    if _, exists := s.tasks[id]; !exists {
        return ErrTaskNotFound
    }

    delete(s.tasks, id)
    return nil
}
```
</details>

### –≠—Ç–∞–ø 3: HTTP handlers

**–ó–∞–¥–∞—á–∞**: –†–µ–∞–ª–∏–∑—É–π—Ç–µ HTTP handlers –¥–ª—è –≤—Å–µ—Ö endpoints.

**–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è**:
- –ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ HTTP —Å—Ç–∞—Ç—É—Å –∫–æ–¥—ã
- JSON —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è/–¥–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è
- –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
- –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ ID –∏–∑ URL

**–ü–æ–¥—Å–∫–∞–∑–∫–∞**:
```go
type TaskHandler struct {
    store *TaskStore
}

func (h *TaskHandler) handleGetTasks(w http.ResponseWriter, r *http.Request) {
    tasks := h.store.GetAll()
    respondJSON(w, http.StatusOK, tasks)
}

func (h *TaskHandler) handleGetTask(w http.ResponseWriter, r *http.Request) {
    // TODO: –∏–∑–≤–ª–µ–∫–∏—Ç–µ ID –∏–∑ URL
    // TODO: –ø–æ–ª—É—á–∏—Ç–µ –∑–∞–¥–∞—á—É –∏–∑ store
    // TODO: –æ–±—Ä–∞–±–æ—Ç–∞–π—Ç–µ –æ—à–∏–±–∫–∏
}

func (h *TaskHandler) handleCreateTask(w http.ResponseWriter, r *http.Request) {
    var task Task
    if err := json.NewDecoder(r.Body).Decode(&task); err != nil {
        respondError(w, http.StatusBadRequest, "invalid request body")
        return
    }

    // TODO: —Å–æ–∑–¥–∞–π—Ç–µ –∑–∞–¥–∞—á—É —á–µ—Ä–µ–∑ store
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
func respondJSON(w http.ResponseWriter, status int, data interface{}) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    json.NewEncoder(w).Encode(data)
}

func respondError(w http.ResponseWriter, status int, message string) {
    respondJSON(w, status, map[string]string{"error": message})
}
```

<details>
<summary>üìñ –†–µ—à–µ–Ω–∏–µ —ç—Ç–∞–ø–∞ 3</summary>

```go
import (
    "encoding/json"
    "net/http"
    "strconv"
    "strings"
)

type TaskHandler struct {
    store *TaskStore
}

func NewTaskHandler(store *TaskStore) *TaskHandler {
    return &TaskHandler{store: store}
}

func (h *TaskHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // –†–æ—É—Ç–∏–Ω–≥ (–ø—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–π, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å chi/gorilla/mux)
    path := strings.TrimPrefix(r.URL.Path, "/api/tasks")

    if path == "" || path == "/" {
        switch r.Method {
        case http.MethodGet:
            h.handleGetTasks(w, r)
        case http.MethodPost:
            h.handleCreateTask(w, r)
        default:
            respondError(w, http.StatusMethodNotAllowed, "method not allowed")
        }
        return
    }

    // –ò–∑–≤–ª–µ–∫–∞–µ–º ID: /api/tasks/123
    id, err := strconv.Atoi(strings.Trim(path, "/"))
    if err != nil {
        respondError(w, http.StatusBadRequest, "invalid task ID")
        return
    }

    switch r.Method {
    case http.MethodGet:
        h.handleGetTask(w, r, id)
    case http.MethodPut:
        h.handleUpdateTask(w, r, id)
    case http.MethodDelete:
        h.handleDeleteTask(w, r, id)
    default:
        respondError(w, http.StatusMethodNotAllowed, "method not allowed")
    }
}

func (h *TaskHandler) handleGetTasks(w http.ResponseWriter, r *http.Request) {
    tasks := h.store.GetAll()
    respondJSON(w, http.StatusOK, tasks)
}

func (h *TaskHandler) handleGetTask(w http.ResponseWriter, r *http.Request, id int) {
    task, err := h.store.GetByID(id)
    if err != nil {
        if errors.Is(err, ErrTaskNotFound) {
            respondError(w, http.StatusNotFound, "task not found")
            return
        }
        respondError(w, http.StatusInternalServerError, "internal error")
        return
    }

    respondJSON(w, http.StatusOK, task)
}

func (h *TaskHandler) handleCreateTask(w http.ResponseWriter, r *http.Request) {
    var task Task
    if err := json.NewDecoder(r.Body).Decode(&task); err != nil {
        respondError(w, http.StatusBadRequest, "invalid request body")
        return
    }

    created, err := h.store.Create(&task)
    if err != nil {
        if errors.Is(err, ErrInvalidTask) {
            respondError(w, http.StatusBadRequest, err.Error())
            return
        }
        respondError(w, http.StatusInternalServerError, "internal error")
        return
    }

    respondJSON(w, http.StatusCreated, created)
}

func (h *TaskHandler) handleUpdateTask(w http.ResponseWriter, r *http.Request, id int) {
    var task Task
    if err := json.NewDecoder(r.Body).Decode(&task); err != nil {
        respondError(w, http.StatusBadRequest, "invalid request body")
        return
    }

    updated, err := h.store.Update(id, &task)
    if err != nil {
        if errors.Is(err, ErrTaskNotFound) {
            respondError(w, http.StatusNotFound, "task not found")
            return
        }
        if errors.Is(err, ErrInvalidTask) {
            respondError(w, http.StatusBadRequest, err.Error())
            return
        }
        respondError(w, http.StatusInternalServerError, "internal error")
        return
    }

    respondJSON(w, http.StatusOK, updated)
}

func (h *TaskHandler) handleDeleteTask(w http.ResponseWriter, r *http.Request, id int) {
    if err := h.store.Delete(id); err != nil {
        if errors.Is(err, ErrTaskNotFound) {
            respondError(w, http.StatusNotFound, "task not found")
            return
        }
        respondError(w, http.StatusInternalServerError, "internal error")
        return
    }

    w.WriteHeader(http.StatusNoContent)
}

func respondJSON(w http.ResponseWriter, status int, data interface{}) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    if err := json.NewEncoder(w).Encode(data); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
    }
}

func respondError(w http.ResponseWriter, status int, message string) {
    respondJSON(w, status, map[string]string{"error": message})
}
```
</details>

### –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ API

```bash
# –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏
curl -X POST http://localhost:8080/api/tasks \
  -H "Content-Type: application/json" \
  -d '{"title":"Learn Go","description":"Complete tutorial"}'

# –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∑–∞–¥–∞—á
curl http://localhost:8080/api/tasks

# –ü–æ–ª—É—á–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ –ø–æ ID
curl http://localhost:8080/api/tasks/1

# –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏
curl -X PUT http://localhost:8080/api/tasks/1 \
  -H "Content-Type: application/json" \
  -d '{"title":"Learn Go","completed":true}'

# –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏
curl -X DELETE http://localhost:8080/api/tasks/1

# Health check
curl http://localhost:8080/health
```

### –ó–∞–¥–∞–Ω–∏—è –¥–ª—è —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ–π —Ä–∞–±–æ—Ç—ã

1. –î–æ–±–∞–≤—å—Ç–µ middleware –¥–ª—è CORS
2. –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é –∑–∞–¥–∞—á (GET /api/tasks?completed=true)
3. –î–æ–±–∞–≤—å—Ç–µ –ø–∞–≥–∏–Ω–∞—Ü–∏—é (GET /api/tasks?page=1&limit=10)
4. –°–æ—Ö—Ä–∞–Ω—è–π—Ç–µ –∑–∞–¥–∞—á–∏ –≤ JSON —Ñ–∞–π–ª –ø—Ä–∏ shutdown
5. –î–æ–±–∞–≤—å—Ç–µ –º–µ—Ç—Ä–∏–∫–∏ (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø—Ä–æ—Å–æ–≤, –≤—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞)
6. –ù–∞–ø–∏—à–∏—Ç–µ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã —Å `httptest`

---

## –ü—Ä–æ–µ–∫—Ç 3: –ö–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö

### –û–ø–∏—Å–∞–Ω–∏–µ

–°–æ–∑–¥–∞–π—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º goroutines –∏ channels.

### –°—Ü–µ–Ω–∞—Ä–∏–π

–û–±—Ä–∞–±–æ—Ç–∫–∞ CSV —Ñ–∞–π–ª–∞ —Å –º–∏–ª–ª–∏–æ–Ω–∞–º–∏ –∑–∞–ø–∏—Å–µ–π:
- –ß—Ç–µ–Ω–∏–µ –∏–∑ —Ñ–∞–π–ª–∞
- –ü–∞—Ä—Å–∏–Ω–≥ —Å—Ç—Ä–æ–∫
- –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
- –ê–≥—Ä–µ–≥–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
- –ó–∞–ø–∏—Å—å –≤ –≤—ã—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª

### –≠—Ç–∞–ø 1: Worker Pool Pattern

**–ó–∞–¥–∞—á–∞**: –†–µ–∞–ª–∏–∑—É–π—Ç–µ worker pool –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö.

**–ü–æ–¥—Å–∫–∞–∑–∫–∞**:
```go
type Job struct {
    ID   int
    Data string
}

type Result struct {
    JobID int
    Value int
    Error error
}

func worker(id int, jobs <-chan Job, results chan<- Result) {
    for job := range jobs {
        // TODO: –æ–±—Ä–∞–±–æ—Ç–∞–π—Ç–µ job
        // TODO: –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ results
    }
}

func main() {
    numWorkers := 5
    jobs := make(chan Job, 100)
    results := make(chan Result, 100)

    // –ó–∞–ø—É—Å–∫–∞–µ–º workers
    for w := 1; w <= numWorkers; w++ {
        go worker(w, jobs, results)
    }

    // TODO: –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º jobs
    // TODO: —Å–æ–±–∏—Ä–∞–µ–º results
}
```

<details>
<summary>üìñ –†–µ—à–µ–Ω–∏–µ —ç—Ç–∞–ø–∞ 1</summary>

```go
package main

import (
    "bufio"
    "fmt"
    "log"
    "os"
    "strconv"
    "strings"
    "sync"
    "time"
)

type Job struct {
    LineNum int
    Line    string
}

type Result struct {
    LineNum int
    Value   int
    Error   error
}

// worker –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç jobs –∏–∑ –∫–∞–Ω–∞–ª–∞
func worker(id int, jobs <-chan Job, results chan<- Result, wg *sync.WaitGroup) {
    defer wg.Done()

    for job := range jobs {
        // –°–∏–º—É–ª—è—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏: –ø–∞—Ä—Å–∏–º —á–∏—Å–ª–æ –∏–∑ —Å—Ç—Ä–æ–∫–∏
        parts := strings.Split(job.Line, ",")
        if len(parts) < 2 {
            results <- Result{
                LineNum: job.LineNum,
                Error:   fmt.Errorf("invalid format"),
            }
            continue
        }

        value, err := strconv.Atoi(strings.TrimSpace(parts[1]))
        if err != nil {
            results <- Result{
                LineNum: job.LineNum,
                Error:   fmt.Errorf("parse error: %w", err),
            }
            continue
        }

        // –°–∏–º—É–ª—è—Ü–∏—è —Ç—è–∂—ë–ª–æ–π —Ä–∞–±–æ—Ç—ã
        time.Sleep(10 * time.Millisecond)

        results <- Result{
            LineNum: job.LineNum,
            Value:   value,
        }
    }
}

func processFile(filename string, numWorkers int) (int, error) {
    file, err := os.Open(filename)
    if err != nil {
        return 0, err
    }
    defer file.Close()

    jobs := make(chan Job, 100)
    results := make(chan Result, 100)

    // –ó–∞–ø—É—Å–∫–∞–µ–º workers
    var wg sync.WaitGroup
    for w := 1; w <= numWorkers; w++ {
        wg.Add(1)
        go worker(w, jobs, results, &wg)
    }

    // Goroutine –¥–ª—è –∑–∞–∫—Ä—ã—Ç–∏—è results –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö workers
    go func() {
        wg.Wait()
        close(results)
    }()

    // Goroutine –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ jobs
    go func() {
        defer close(jobs)

        scanner := bufio.NewScanner(file)
        lineNum := 0

        for scanner.Scan() {
            lineNum++
            jobs <- Job{
                LineNum: lineNum,
                Line:    scanner.Text(),
            }
        }

        if err := scanner.Err(); err != nil {
            log.Printf("Scanner error: %v", err)
        }
    }()

    // –°–æ–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    var sum int
    var errorCount int

    for result := range results {
        if result.Error != nil {
            errorCount++
            log.Printf("Line %d error: %v", result.LineNum, result.Error)
            continue
        }
        sum += result.Value
    }

    log.Printf("Processed with %d errors", errorCount)
    return sum, nil
}

func main() {
    if len(os.Args) < 2 {
        fmt.Println("Usage: program <filename>")
        os.Exit(1)
    }

    filename := os.Args[1]
    numWorkers := 5

    start := time.Now()
    sum, err := processFile(filename, numWorkers)
    if err != nil {
        log.Fatalf("Error: %v", err)
    }

    fmt.Printf("Sum: %d\n", sum)
    fmt.Printf("Time: %v\n", time.Since(start))
}
```
</details>

### –≠—Ç–∞–ø 2: Pipeline Pattern

**–ó–∞–¥–∞—á–∞**: –†–µ–∞–ª–∏–∑—É–π—Ç–µ pipeline –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö.

**–°—Ö–µ–º–∞**:
```
Reader ‚Üí Parser ‚Üí Validator ‚Üí Aggregator ‚Üí Writer
```

**–ü–æ–¥—Å–∫–∞–∑–∫–∞**:
```go
func reader(filename string) <-chan string {
    out := make(chan string)
    go func() {
        defer close(out)
        // TODO: —á–∏—Ç–∞–π—Ç–µ —Ñ–∞–π–ª –ø–æ—Å—Ç—Ä–æ—á–Ω–æ
        // TODO: –æ—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ —Å—Ç—Ä–æ–∫–∏ –≤ out
    }()
    return out
}

func parser(in <-chan string) <-chan Record {
    out := make(chan Record)
    go func() {
        defer close(out)
        for line := range in {
            // TODO: –ø–∞—Ä—Å–∏—Ç–µ —Å—Ç—Ä–æ–∫—É –≤ Record
            // TODO: –æ—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ –≤ out
        }
    }()
    return out
}

func validator(in <-chan Record) <-chan Record {
    // TODO: –≤–∞–ª–∏–¥–∏—Ä—É–π—Ç–µ Record
    return out
}

func main() {
    lines := reader("data.csv")
    records := parser(lines)
    valid := validator(records)

    // TODO: –∞–≥—Ä–µ–≥–∏—Ä—É–π—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
}
```

<details>
<summary>üìñ –†–µ—à–µ–Ω–∏–µ —ç—Ç–∞–ø–∞ 2</summary>

```go
type Record struct {
    ID    int
    Name  string
    Value int
}

func reader(filename string) <-chan string {
    out := make(chan string, 100)

    go func() {
        defer close(out)

        file, err := os.Open(filename)
        if err != nil {
            log.Printf("Open file error: %v", err)
            return
        }
        defer file.Close()

        scanner := bufio.NewScanner(file)
        for scanner.Scan() {
            out <- scanner.Text()
        }

        if err := scanner.Err(); err != nil {
            log.Printf("Scanner error: %v", err)
        }
    }()

    return out
}

func parser(in <-chan string) <-chan Record {
    out := make(chan Record, 100)

    go func() {
        defer close(out)

        for line := range in {
            parts := strings.Split(line, ",")
            if len(parts) < 3 {
                continue
            }

            id, err := strconv.Atoi(strings.TrimSpace(parts[0]))
            if err != nil {
                continue
            }

            value, err := strconv.Atoi(strings.TrimSpace(parts[2]))
            if err != nil {
                continue
            }

            out <- Record{
                ID:    id,
                Name:  strings.TrimSpace(parts[1]),
                Value: value,
            }
        }
    }()

    return out
}

func validator(in <-chan Record) <-chan Record {
    out := make(chan Record, 100)

    go func() {
        defer close(out)

        for record := range in {
            // –í–∞–ª–∏–¥–∞—Ü–∏—è
            if record.ID <= 0 || record.Name == "" || record.Value < 0 {
                continue
            }

            out <- record
        }
    }()

    return out
}

func aggregator(in <-chan Record) <-chan int {
    out := make(chan int)

    go func() {
        defer close(out)

        sum := 0
        for record := range in {
            sum += record.Value
        }

        out <- sum
    }()

    return out
}

func main() {
    filename := "data.csv"

    // Pipeline
    lines := reader(filename)
    records := parser(lines)
    valid := validator(records)
    result := aggregator(valid)

    // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    sum := <-result
    fmt.Printf("Total sum: %d\n", sum)
}
```
</details>

### –ó–∞–¥–∞–Ω–∏—è –¥–ª—è —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ–π —Ä–∞–±–æ—Ç—ã

1. –î–æ–±–∞–≤—å—Ç–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è graceful cancellation
2. –†–µ–∞–ª–∏–∑—É–π—Ç–µ rate limiting –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
3. –î–æ–±–∞–≤—å—Ç–µ –º–µ—Ç—Ä–∏–∫–∏: throughput, latency
4. –†–µ–∞–ª–∏–∑—É–π—Ç–µ retry –º–µ—Ö–∞–Ω–∏–∑–º –¥–ª—è failed jobs
5. –î–æ–±–∞–≤—å—Ç–µ –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä –∏—Å–ø–æ–ª—å–∑—É—è `github.com/schollz/progressbar`

---

## –ü—Ä–æ–µ–∫—Ç 4: –ü–∞—Ä—Å–µ—Ä –ª–æ–≥–æ–≤

### –û–ø–∏—Å–∞–Ω–∏–µ

–°–æ–∑–¥–∞–π—Ç–µ —É—Ç–∏–ª–∏—Ç—É –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –ª–æ–≥-—Ñ–∞–π–ª–æ–≤ —Å –∞–≥—Ä–µ–≥–∞—Ü–∏–µ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.

### –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å

```bash
# –ê–Ω–∞–ª–∏–∑ –ª–æ–≥-—Ñ–∞–π–ª–∞
logparser analyze access.log

# –í—ã–≤–æ–¥:
# Total requests: 100500
# Unique IPs: 1234
# Status codes:
#   200: 98000 (97.5%)
#   404: 1500 (1.5%)
#   500: 1000 (1.0%)
# Top URLs:
#   /api/users: 50000
#   /api/products: 30000
```

### –§–æ—Ä–º–∞—Ç –ª–æ–≥–∞ (Apache Combined)

```
127.0.0.1 - - [10/Oct/2024:13:55:36 +0000] "GET /api/users HTTP/1.1" 200 1234
```

### –ó–∞–¥–∞—á–∞

–†–µ–∞–ª–∏–∑—É–π—Ç–µ –ø–∞—Ä—Å–µ—Ä —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º:
- –†–µ–≥—É–ª—è—Ä–Ω—ã—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏–π –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞
- Map –¥–ª—è –∞–≥—Ä–µ–≥–∞—Ü–∏–∏
- Goroutines –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
- Channels –¥–ª—è —Å–±–æ—Ä–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤

<details>
<summary>üìñ –†–µ—à–µ–Ω–∏–µ</summary>

```go
package main

import (
    "bufio"
    "flag"
    "fmt"
    "log"
    "os"
    "regexp"
    "sort"
    "sync"
)

type LogEntry struct {
    IP         string
    Timestamp  string
    Method     string
    URL        string
    StatusCode int
    Size       int
}

type Stats struct {
    mu          sync.Mutex
    totalReqs   int
    ips         map[string]int
    statusCodes map[int]int
    urls        map[string]int
}

func NewStats() *Stats {
    return &Stats{
        ips:         make(map[string]int),
        statusCodes: make(map[int]int),
        urls:        make(map[string]int),
    }
}

func (s *Stats) Add(entry LogEntry) {
    s.mu.Lock()
    defer s.mu.Unlock()

    s.totalReqs++
    s.ips[entry.IP]++
    s.statusCodes[entry.StatusCode]++
    s.urls[entry.URL]++
}

func (s *Stats) Print() {
    s.mu.Lock()
    defer s.mu.Unlock()

    fmt.Printf("\nLog Analysis Results\n")
    fmt.Printf("====================\n\n")

    fmt.Printf("Total requests: %d\n", s.totalReqs)
    fmt.Printf("Unique IPs: %d\n\n", len(s.ips))

    fmt.Println("Status codes:")
    for code, count := range s.statusCodes {
        pct := float64(count) / float64(s.totalReqs) * 100
        fmt.Printf("  %d: %d (%.1f%%)\n", code, count, pct)
    }

    // –¢–æ–ø-10 URLs
    type urlCount struct {
        url   string
        count int
    }

    urlCounts := make([]urlCount, 0, len(s.urls))
    for url, count := range s.urls {
        urlCounts = append(urlCounts, urlCount{url, count})
    }

    sort.Slice(urlCounts, func(i, j int) bool {
        return urlCounts[i].count > urlCounts[j].count
    })

    fmt.Println("\nTop 10 URLs:")
    for i := 0; i < 10 && i < len(urlCounts); i++ {
        fmt.Printf("  %s: %d\n", urlCounts[i].url, urlCounts[i].count)
    }
}

var logRegex = regexp.MustCompile(
    `^(\S+) \S+ \S+ \[([\w:/]+\s[+\-]\d{4})\] "(\S+)\s?(\S+)?\s?(\S+)?" (\d{3}|-) (\d+|-)`,
)

func parseLine(line string) (*LogEntry, error) {
    matches := logRegex.FindStringSubmatch(line)
    if len(matches) < 8 {
        return nil, fmt.Errorf("invalid format")
    }

    var statusCode int
    fmt.Sscanf(matches[6], "%d", &statusCode)

    var size int
    fmt.Sscanf(matches[7], "%d", &size)

    return &LogEntry{
        IP:         matches[1],
        Timestamp:  matches[2],
        Method:     matches[3],
        URL:        matches[4],
        StatusCode: statusCode,
        Size:       size,
    }, nil
}

func processFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close()

    stats := NewStats()
    scanner := bufio.NewScanner(file)
    lineNum := 0

    for scanner.Scan() {
        lineNum++
        line := scanner.Text()

        entry, err := parseLine(line)
        if err != nil {
            log.Printf("Line %d: %v", lineNum, err)
            continue
        }

        stats.Add(*entry)
    }

    if err := scanner.Err(); err != nil {
        return err
    }

    stats.Print()
    return nil
}

func main() {
    flag.Parse()

    if flag.NArg() < 1 {
        fmt.Println("Usage: logparser <logfile>")
        os.Exit(1)
    }

    filename := flag.Arg(0)

    if err := processFile(filename); err != nil {
        log.Fatalf("Error: %v", err)
    }
}
```
</details>

---

## –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∑–∞–¥–∞—á–∏

### 1. Rate Limiter

–†–µ–∞–ª–∏–∑—É–π—Ç–µ rate limiter —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∫–∞–Ω–∞–ª–æ–≤:

```go
type RateLimiter struct {
    rate  int           // requests per second
    burst int           // max burst size
    tokens chan struct{}
}

func NewRateLimiter(rate, burst int) *RateLimiter {
    // TODO: —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ
}

func (rl *RateLimiter) Allow() bool {
    // TODO: —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ
}
```

### 2. Cache —Å TTL

–†–µ–∞–ª–∏–∑—É–π—Ç–µ in-memory cache —Å expiration:

```go
type Cache struct {
    mu    sync.RWMutex
    items map[string]cacheItem
}

type cacheItem struct {
    value      interface{}
    expiration time.Time
}

func (c *Cache) Set(key string, value interface{}, ttl time.Duration) {
    // TODO: —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ
}

func (c *Cache) Get(key string) (interface{}, bool) {
    // TODO: —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π expiration
}
```

### 3. Graceful Worker Pool

–†–µ–∞–ª–∏–∑—É–π—Ç–µ worker pool —Å graceful shutdown:

```go
type WorkerPool struct {
    workers   int
    jobQueue  chan Job
    wg        sync.WaitGroup
    ctx       context.Context
    cancel    context.CancelFunc
}

func (wp *WorkerPool) Start() {
    // TODO: –∑–∞–ø—É—Å—Ç–∏—Ç–µ workers
}

func (wp *WorkerPool) Stop() {
    // TODO: graceful shutdown
}
```

---

## –†–µ—à–µ–Ω–∏—è –∏ –ø–æ–¥—Å–∫–∞–∑–∫–∏

### –û–±—â–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏

1. **Error handling**:
   - –í—Å–µ–≥–¥–∞ –ø—Ä–æ–≤–µ—Ä—è–π—Ç–µ –æ—à–∏–±–∫–∏
   - –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `fmt.Errorf` —Å `%w` –¥–ª—è wrapping
   - –õ–æ–≥–∏—Ä—É–π—Ç–µ –æ—à–∏–±–∫–∏ —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º

2. **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**:
   - –ü–∏—à–∏—Ç–µ unit-—Ç–µ—Å—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –º–æ–¥—É–ª—è
   - –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ table-driven tests
   - –¢–µ—Å—Ç–∏—Ä—É–π—Ç–µ –≥—Ä–∞–Ω–∏—á–Ω—ã–µ —Å–ª—É—á–∞–∏

3. **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**:
   - –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `pprof` –¥–ª—è –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏—è
   - –ü–∏—à–∏—Ç–µ benchmarks
   - –ò–∑–±–µ–≥–∞–π—Ç–µ –∞–ª–ª–æ–∫–∞—Ü–∏–π –≤ –≥–æ—Ä—è—á–∏—Ö –ø—É—Ç—è—Ö

4. **Concurrency**:
   - –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `context.Context` –¥–ª—è cancellation
   - –ò–∑–±–µ–≥–∞–π—Ç–µ shared state
   - –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–π—Ç–µ channels –¥–ª—è –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–∏

### –ü–æ–ª–µ–∑–Ω—ã–µ –ø–∞–∫–µ—Ç—ã

```go
// CLI
"flag"                                    // –§–ª–∞–≥–∏ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
"github.com/spf13/cobra"                  // –ú–æ—â–Ω—ã–π CLI framework

// HTTP
"net/http"                                // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π HTTP
"github.com/go-chi/chi"                   // –†–æ—É—Ç–µ—Ä
"github.com/gorilla/mux"                  // –†–æ—É—Ç–µ—Ä

// –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
"log/slog"                                // –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ª–æ–≥–∏ (Go 1.21+)
"github.com/sirupsen/logrus"              // –ü–æ–ø—É–ª—è—Ä–Ω—ã–π logger

// –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
"testing"                                 // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
"github.com/stretchr/testify/assert"     // Assertions

// Concurrency
"context"                                 // –ö–æ–Ω—Ç–µ–∫—Å—Ç—ã
"golang.org/x/sync/errgroup"             // –ì—Ä—É–ø–ø–æ–≤—ã–µ goroutines

// –§–∞–π–ª—ã
"os"                                      // –§–∞–π–ª–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞
"path/filepath"                           // –ü—É—Ç–∏ –∫ —Ñ–∞–π–ª–∞–º
"io"                                      // I/O –æ–ø–µ—Ä–∞—Ü–∏–∏
```

---

## –ß–µ–∫-–ª–∏—Å—Ç

–ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—Ä–∞–∫—Ç–∏–∫–∏ –≤—ã –¥–æ–ª–∂–Ω—ã —É–º–µ—Ç—å:

- [ ] –°–æ–∑–¥–∞–≤–∞—Ç—å CLI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å —Ñ–ª–∞–≥–∞–º–∏ –∏ –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏
- [ ] –ß–∏—Ç–∞—Ç—å –∏ –∑–∞–ø–∏—Å—ã–≤–∞—Ç—å —Ñ–∞–π–ª—ã —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ
- [ ] –ü–∞—Ä—Å–∏—Ç—å –¥–∞–Ω–Ω—ã–µ (CSV, JSON, –ª–æ–≥–∏)
- [ ] –°–æ–∑–¥–∞–≤–∞—Ç—å HTTP —Å–µ—Ä–≤–µ—Ä—ã –∏ API
- [ ] –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å JSON –∑–∞–ø—Ä–æ—Å—ã/–æ—Ç–≤–µ—Ç—ã
- [ ] –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å goroutines –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–∞
- [ ] –†–∞–±–æ—Ç–∞—Ç—å —Å channels –¥–ª—è –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–∏
- [ ] –†–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å –ø–∞—Ç—Ç–µ—Ä–Ω—ã: worker pool, pipeline
- [ ] –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –æ—à–∏–±–∫–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ
- [ ] –ü–∏—Å–∞—Ç—å —Ç–µ—Å—Ç—ã –¥–ª—è –∫–æ–¥–∞
- [ ] –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å context –¥–ª—è cancellation
- [ ] –î–µ–ª–∞—Ç—å graceful shutdown

---

## –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏

–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –∑–∞–≤–µ—Ä—à–∏–ª–∏ **–ß–∞—Å—Ç—å 1: –û—Å–Ω–æ–≤—ã Go**.

### –ß—Ç–æ –¥–∞–ª—å—à–µ?

1. **–ß–∞—Å—Ç—å 2: –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Ç–µ–º—ã** ‚Äî –≥–æ—Ä—É—Ç–∏–Ω—ã, –∫–∞–Ω–∞–ª—ã, –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫, GC
2. **–ß–∞—Å—Ç—å 3: Web & API** ‚Äî –≤–µ–±-—Ñ—Ä–µ–π–º–≤–æ—Ä–∫–∏, gRPC, WebSockets
3. **–ß–∞—Å—Ç—å 4: –ò–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞** ‚Äî Docker, Kubernetes, –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
4. **–ß–∞—Å—Ç—å 5: –ü—Ä–æ–µ–∫—Ç—ã** ‚Äî —Ä–µ–∞–ª—å–Ω—ã–µ production-ready –ø—Ä–æ–µ–∫—Ç—ã

### –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã

- [Go by Example](https://gobyexample.com/)
- [Effective Go](https://go.dev/doc/effective_go)
- [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)
- [100 Go Mistakes](https://100go.co/)

---

**–í–æ–ø—Ä–æ—Å—ã?** –û—Ç–∫—Ä–æ–π issue –Ω–∞ [GitHub](https://github.com/AlexandrTolstuhin/csharp-to-go/issues)

[‚Üê –ù–∞–∑–∞–¥: –ö–ª—é—á–µ–≤—ã–µ –æ—Ç–ª–∏—á–∏—è –æ—Ç C#](03_key_differences.md) | [–í–ø–µ—Ä—ë–¥: –ß–∞—Å—Ç—å 2 ‚Üí](../part2-advanced/README.md)
