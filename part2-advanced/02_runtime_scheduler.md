# 2.2 Go Runtime ะธ ะฟะปะฐะฝะธัะพะฒัะธะบ

## ะกะพะดะตัะถะฐะฝะธะต
- [ะะฒะตะดะตะฝะธะต](#ะฒะฒะตะดะตะฝะธะต)
- [ะััะธัะตะบัััะฐ GMP](#ะฐััะธัะตะบัััะฐ-gmp)
- [Work-Stealing ะฐะปะณะพัะธัะผ](#work-stealing-ะฐะปะณะพัะธัะผ)
- [Preemption (ะฒััะตัะฝะตะฝะธะต)](#preemption-ะฒััะตัะฝะตะฝะธะต)
- [GOMAXPROCS](#gomaxprocs)
- [ะกัะฐะฒะฝะตะฝะธะต ั .NET ThreadPool](#ััะฐะฒะฝะตะฝะธะต-ั-net-threadpool)
- [ะขัะฐััะธัะพะฒะบะฐ ะธ ะดะธะฐะณะฝะพััะธะบะฐ](#ััะฐััะธัะพะฒะบะฐ-ะธ-ะดะธะฐะณะฝะพััะธะบะฐ)
- [ะะฟัะธะผะธะทะฐัะธั ะฟะพะด ะฟะปะฐะฝะธัะพะฒัะธะบ](#ะพะฟัะธะผะธะทะฐัะธั-ะฟะพะด-ะฟะปะฐะฝะธัะพะฒัะธะบ)
- [ะัะฐะบัะธัะตัะบะธะต ะฟัะธะผะตัั](#ะฟัะฐะบัะธัะตัะบะธะต-ะฟัะธะผะตัั)
- [ะงะตะบ-ะปะธัั](#ัะตะบ-ะปะธัั)

---

## ะะฒะตะดะตะฝะธะต

Go runtime ะฒะบะปััะฐะตั ะฒ ัะตะฑั **ะฟะปะฐะฝะธัะพะฒัะธะบ ะณะพัััะธะฝ** (goroutine scheduler), ะบะพัะพััะน ัััะตะบัะธะฒะฝะพ ะผัะปััะธะฟะปะตะบัะธััะตั ะผะธะปะปะธะพะฝั ะณะพัััะธะฝ ะฝะฐ ะพะณัะฐะฝะธัะตะฝะฝะพะต ะบะพะปะธัะตััะฒะพ OS threads.

### ะะพัะตะผั ััะพ ะฒะฐะถะฝะพ?

**C# ัะฐะทัะฐะฑะพััะธะบะธ** ะฟัะธะฒัะบะปะธ ะบ ัะพะผั, ััะพ:
- Task ัะฐะฑะพัะฐะตั ะฝะฐ ThreadPool
- ThreadPool ัะฟัะฐะฒะปัะตั OS threads
- Async/await - ััะพ ัะธะฝัะฐะบัะธัะตัะบะธะน ัะฐัะฐั ะฝะฐะด callbacks

**ะ Go**:
- ะะพัััะธะฝั ะะ ัะฐะฒะฝั OS threads
- Go runtime ัะฐะผ ัะฟัะฐะฒะปัะตั ะผะฐะฟะฟะธะฝะณะพะผ ะณะพัััะธะฝ ะฝะฐ threads
- ะะพะฝะธะผะฐะฝะธะต ะฟะปะฐะฝะธัะพะฒัะธะบะฐ ะบัะธัะธัะฝะพ ะดะปั ะฟัะพะธะทะฒะพะดะธัะตะปัะฝะพััะธ

> ๐ก **ะะปััะตะฒะพะต ะพัะปะธัะธะต**: ะ C# ะฒั ัะฐะฑะพัะฐะตัะต ั ThreadPool ะฝะฐะฟััะผัั, ะฒ Go - ัะตัะตะท runtime ะฟะปะฐะฝะธัะพะฒัะธะบ, ะบะพัะพััะน ะฝะฐะผะฝะพะณะพ ัััะตะบัะธะฒะฝะตะต.

---

## ะััะธัะตะบัััะฐ GMP

GMP - ััะพ ะผะพะดะตะปั ะฟะปะฐะฝะธัะพะฒัะธะบะฐ Go:
- **G** (Goroutine) - ะณะพัััะธะฝะฐ
- **M** (Machine) - OS thread
- **P** (Processor) - ะบะพะฝัะตะบัั ะฒัะฟะพะปะฝะตะฝะธั

### ะะพะผะฟะพะฝะตะฝัั

#### G - Goroutine

ะะพัััะธะฝะฐ - ััะพ ะปะตะณะบะพะฒะตัะฝัะน ะฟะพัะพะบ ะฒัะฟะพะปะฝะตะฝะธั.

**ะฅะฐัะฐะบัะตัะธััะธะบะธ**:
- ะกัะตะบ: ะฝะฐัะธะฝะฐะตััั ั 2KB (ะดะธะฝะฐะผะธัะตัะบะธ ัะฐัััั ะดะพ 1GB)
- ะกะพััะพัะฝะธะต: running, runnable, waiting, dead
- ะฅัะฐะฝะธั: SP (stack pointer), PC (program counter), ัะตะณะธัััั

```go
type g struct {
    stack       stack   // ะกัะตะบ ะณะพัััะธะฝั
    stackguard0 uintptr // ะะฐัะธัะฐ ะพั ะฟะตัะตะฟะพะปะฝะตะฝะธั
    m           *m      // ะขะตะบััะธะน M (thread)
    sched       gobuf   // ะะพะฝัะตะบัั (SP, PC, ัะตะณะธัััั)
    // ... ะดััะณะธะต ะฟะพะปั
}
```

**C# ะฐะฝะฐะปะพะณ**:
```csharp
// Task - ััะพ NOT thread, ะฝะพ ะฒััะพะบะพััะพะฒะฝะตะฒะฐั ะฐะฑัััะฐะบัะธั
var task = Task.Run(() => DoWork());

// Thread - ััะพ OS thread
var thread = new Thread(() => DoWork());
```

#### M - Machine (OS Thread)

Machine ะฟัะตะดััะฐะฒะปัะตั ัะตะฐะปัะฝัะน OS thread.

**ะฅะฐัะฐะบัะตัะธััะธะบะธ**:
- ะกะพะพัะฒะตัััะฒัะตั OS thread (pthread ะฝะฐ Linux, thread ะฝะฐ Windows)
- ะัะฟะพะปะฝัะตั ะณะพัััะธะฝั
- ะะพะถะตั ะฑะปะพะบะธัะพะฒะฐัััั (syscall, cgo)
- ะะฐะบัะธะผัะผ: 10000 (ะพะณัะฐะฝะธัะตะฝะธะต runtime)

```go
type m struct {
    g0      *g    // ะะพัััะธะฝะฐ ะดะปั ะฟะปะฐะฝะธัะพะฒัะธะบะฐ
    curg    *g    // ะขะตะบััะฐั ะฒัะฟะพะปะฝัััะฐััั ะณะพัััะธะฝะฐ
    p       *p    // ะัะธะฒัะทะฐะฝะฝัะน P
    nextp   *p    // P ะดะปั ัะปะตะดัััะตะณะพ ะทะฐะฟััะบะฐ
    // ... ะดััะณะธะต ะฟะพะปั
}
```

**ะะฐะถะฝะพ**: M ะผะพะถะตั ัััะตััะฒะพะฒะฐัั ะฑะตะท P (ะทะฐะฑะปะพะบะธัะพะฒะฐะฝ), ะฝะพ ะฝะต ะผะพะถะตั ะฒัะฟะพะปะฝััั Go ะบะพะด.

#### P - Processor (ะบะพะฝัะตะบัั ะฒัะฟะพะปะฝะตะฝะธั)

P ะฟัะตะดััะฐะฒะปัะตั **ะปะพะณะธัะตัะบะธะน ะฟัะพัะตััะพั** - ัะตัััั, ะฝะตะพะฑัะพะดะธะผัะน ะดะปั ะฒัะฟะพะปะฝะตะฝะธั Go ะบะพะดะฐ.

**ะฅะฐัะฐะบัะตัะธััะธะบะธ**:
- ะะพะปะธัะตััะฒะพ: `GOMAXPROCS` (ะฟะพ ัะผะพะปัะฐะฝะธั = ะบะพะปะธัะตััะฒะพ CPU cores)
- ะกะพะดะตัะถะธั local run queue ะณะพัััะธะฝ
- ะะตั ะดะปั ะฐะปะปะพะบะฐัะธะน (mcache)
- ะะพะถะตั ะฑััั ะฟะตัะตะดะฐะฝ ะผะตะถะดั M

```go
type p struct {
    m           *m       // ะขะตะบััะธะน M
    runqhead    uint32   // ะะพะปะพะฒะฐ local run queue
    runqtail    uint32   // ะฅะฒะพัั local run queue
    runq        [256]guintptr // Local run queue
    runnext     guintptr // ะกะปะตะดัััะฐั ะณะพัััะธะฝะฐ (ะฟัะธะพัะธัะตั)
    // ... ะดััะณะธะต ะฟะพะปั
}
```

### ะะทะฐะธะผะพะดะตะนััะฒะธะต GMP

```
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
โ              Global Run Queue                    โ
โ  (ะณะพัััะธะฝั, ะพะถะธะดะฐััะธะต ะฒัะฟะพะปะฝะตะฝะธั)               โ
โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ
              โ          โ          โ
    โโโโโโโโโโโ   โโโโโโโโโโโ   โโโโโโโโโโโ
    โ    P0   โ   โ    P1   โ   โ    P2   โ
    โ โโโโโโโ โ   โ โโโโโโโ โ   โ โโโโโโโ โ
    โ โ LRQ โ โ   โ โ LRQ โ โ   โ โ LRQ โ โ  Local Run Queues
    โ โโโโโโโ โ   โ โโโโโโโ โ   โ โโโโโโโ โ
    โโโโโโฌโโโโโ   โโโโโโฌโโโโโ   โโโโโโฌโโโโโ
         โ             โ             โ
    โโโโโโผโโโโโ   โโโโโโผโโโโโ   โโโโโโผโโโโโ
    โ    M0   โ   โ    M1   โ   โ    M2   โ  OS Threads
    โโโโโโโโโโโ   โโโโโโโโโโโ   โโโโโโโโโโโ
         โ             โ             โ
    โโโโโโผโโโโโ   โโโโโโผโโโโโ   โโโโโโผโโโโโ
    โ    G1   โ   โ    G5   โ   โ    G9   โ  ะะพัััะธะฝั
    โ    G2   โ   โ    G6   โ   โ   G10   โ
    โ    G3   โ   โ    G7   โ   โ   G11   โ
    โ    G4   โ   โ    G8   โ   โ   G12   โ
    โโโโโโโโโโโ   โโโโโโโโโโโ   โโโโโโโโโโโ
```

### ะะธะทะฝะตะฝะฝัะน ัะธะบะป

1. **ะกะพะทะดะฐะฝะธะต ะณะพัััะธะฝั** (`go func()`)
   - ะกะพะทะดะฐัััั ััััะบัััะฐ G
   - ะะพะฑะฐะฒะปัะตััั ะฒ run queue

2. **ะะปะฐะฝะธัะพะฒะฐะฝะธะต**
   - M ะฑะตััั G ะธะท local run queue ัะฒะพะตะณะพ P
   - ะัะปะธ ะฟัััะพ - ะฟััะฐะตััั ัะบัะฐััั ะธะท ะดััะณะธั P (work-stealing)
   - ะัะปะธ ะฒะตะทะดะต ะฟัััะพ - ะฑะตััั ะธะท global run queue

3. **ะัะฟะพะปะฝะตะฝะธะต**
   - M ะฒัะฟะพะปะฝัะตั G
   - ะัะธ ะฑะปะพะบะธัะพะฒะบะต (channel, syscall) - G ัะฝะธะผะฐะตััั ั M

4. **ะะฐะฒะตััะตะฝะธะต**
   - G ะฒะพะทะฒัะฐัะฐะตััั ะฒ pool ะดะปั ะฟะตัะตะธัะฟะพะปัะทะพะฒะฐะฝะธั
   - M ะธัะตั ัะปะตะดััััั G

### ะกัะฐะฒะฝะตะฝะธะต ั .NET ThreadPool

| ะัะฟะตะบั | .NET ThreadPool | Go Scheduler |
|--------|-----------------|--------------|
| **ะะดะธะฝะธัะฐ ัะฐะฑะพัั** | Task | Goroutine (G) |
| **Worker** | OS Thread | M (OS Thread) + P |
| **ะัะตัะตะดั** | Global queue | Local (P) + Global |
| **Stealing** | ะะฐ (ะพะณัะฐะฝะธัะตะฝะฝัะน) | ะะฐ (ะฐะณัะตััะธะฒะฝัะน) |
| **ะะพะฝัะตะบัั** | ะะตั | P (ะฟัะพัะตััะพั) |
| **Preemption** | Cooperative (.NET < 6) | Cooperative + Signal-based |
| **Max workers** | ~1000-2000 threads | 10000 M, unlimited G |

---

## Work-Stealing ะฐะปะณะพัะธัะผ

Work-stealing - ััะพ ะผะตัะฐะฝะธะทะผ ะฑะฐะปะฐะฝัะธัะพะฒะบะธ ะฝะฐะณััะทะบะธ ะผะตะถะดั P.

### ะะฐะบ ัะฐะฑะพัะฐะตั

```
P0 (ะทะฐะฝัั)          P1 (ะฟัะพััะฐะธะฒะฐะตั)
โโโโโโโโโโ          โโโโโโโโโโ
โ G1     โ          โ        โ
โ G2     โ   steal โ        โ
โ G3     โ  โโโโโโโ>  G3    โ
โ G4     โ          โ        โ
โโโโโโโโโโ          โโโโโโโโโโ
```

**ะะปะณะพัะธัะผ**:
1. P ะฟัะพะฒะตััะตั ัะฒะพะน local run queue
2. ะัะปะธ ะฟัััะพ โ ะฟัะพะฒะตััะตั global run queue
3. ะัะปะธ ะฟัััะพ โ **ะบัะฐะดัั** ะฟะพะปะพะฒะธะฝั ะณะพัััะธะฝ ะธะท ะดััะณะพะณะพ P
4. ะัะปะธ ะฒะตะทะดะต ะฟัััะพ โ ะฟะตัะตัะพะดะธั ะฒ ัะตะถะธะผ ะพะถะธะดะฐะฝะธั

### ะะตะฐะปะธะทะฐัะธั

```go
// ะฃะฟัะพััะฝะฝะฐั ะฒะตััะธั
func findrunnable() *g {
    // 1. ะัะพะฒะตััะตะผ local run queue
    if gp := runqget(_p_); gp != nil {
        return gp
    }

    // 2. ะัะพะฒะตััะตะผ global run queue
    if gp := globrunqget(_p_); gp != nil {
        return gp
    }

    // 3. Work-stealing: ะฟัะพะฑัะตะผ ัะบัะฐััั ะธะท ะดััะณะธั P
    for i := 0; i < len(allp); i++ {
        p := allp[(i+offset)%len(allp)]
        if gp := runqsteal(_p_, p); gp != nil {
            return gp
        }
    }

    // 4. ะะธัะตะณะพ ะฝะต ะฝะฐัะปะธ - ะทะฐััะฟะฐะตะผ
    stopm()
}
```

### C# ะฐะฝะฐะปะพะณ

**.NET 6+ ThreadPool** ัะฐะบะถะต ะธัะฟะพะปัะทัะตั work-stealing, ะฝะพ:

```csharp
// .NET ThreadPool (ัะฟัะพััะฝะฝะพ)
// - ะะฐะถะดัะน thread ะธะผะตะตั local queue
// - Stealing ะฟัะพะธััะพะดะธั ัะตะถะต
// - Global queue ะธะผะตะตั ะฑะพะปะตะต ะฒััะพะบะธะน ะฟัะธะพัะธัะตั

ThreadPool.QueueUserWorkItem(_ => DoWork());
```

**ะัะปะธัะธั**:
- Go stealing ะฑะพะปะตะต ะฐะณัะตััะธะฒะฝัะน
- Go ะฟัะพะฒะตััะตั local queue ัะฐัะต
- Go ะธะผะตะตั ะดะฒะฐ ััะพะฒะฝั: local (P) ะธ global

### ะะฟัะธะผะธะทะฐัะธั ะดะปั work-stealing

```go
// โ ะะปะพัะพ: ัะพะทะดะฐัะผ ะดะธัะฑะฐะปะฐะฝั
func bad() {
    for i := 0; i < 1000000; i++ {
        go func() {
            // ะัะตะฝั ะบะพัะพัะบะฐั ัะฐะฑะพัะฐ
            _ = i * 2
        }()
    }
}

// โ ะฅะพัะพัะพ: ะธัะฟะพะปัะทัะตะผ worker pool
func good() {
    const numWorkers = 10
    jobs := make(chan int, 1000)

    for w := 0; w < numWorkers; w++ {
        go func() {
            for job := range jobs {
                _ = job * 2
            }
        }()
    }

    for i := 0; i < 1000000; i++ {
        jobs <- i
    }
    close(jobs)
}
```

---

## Preemption (ะฒััะตัะฝะตะฝะธะต)

Preemption - ััะพ ะผะตัะฐะฝะธะทะผ, ะฟะพะทะฒะพะปัััะธะน ะฟะปะฐะฝะธัะพะฒัะธะบั **ะฟัะตััะฒะฐัั** ะฒัะฟะพะปะฝััััััั ะณะพัััะธะฝั.

### ะััะพัะธั

**Go 1.0-1.13**: Cooperative preemption
- ะะพัััะธะฝะฐ ะฒััะตัะฝัะปะฐัั ัะพะปัะบะพ ะฒ safe points (function calls)
- ะัะพะฑะปะตะผะฐ: ะฑะตัะบะพะฝะตัะฝัะน ัะธะบะป ะฑะตะท ะฒัะทะพะฒะพะฒ ััะฝะบัะธะน ะฑะปะพะบะธัะพะฒะฐะป P

```go
// ะัะพะฑะปะตะผะฐ ะฒ Go < 1.14
func loop() {
    for {
        // ะะตั function calls - ะฝะต ะฒััะตัะฝัะตััั
        i := 0
        i++
    }
}
```

**Go 1.14+**: Signal-based preemption (ะฐัะธะฝััะพะฝะฝัะน)
- Runtime ะผะพะถะตั ะฟัะตัะฒะฐัั ะณะพัััะธะฝั ะฒ ะปัะฑะพะน ะผะพะผะตะฝั
- ะัะฟะพะปัะทัะตั OS signals (SIGURG ะฝะฐ Unix)

### ะะฐะบ ัะฐะฑะพัะฐะตั preemption

```
G ะฒัะฟะพะปะฝัะตััั > 10ms
         โ
ะะปะฐะฝะธัะพะฒัะธะบ ะพัะฟัะฐะฒะปัะตั signal
         โ
G ัะพััะฐะฝัะตั ะบะพะฝัะตะบัั
         โ
G ะฟะตัะตะผะตัะฐะตััั ะฒ run queue
         โ
M ะฒัะฟะพะปะฝัะตั ะดััะณัั G
```

**ะะพะด ะฟะปะฐะฝะธัะพะฒัะธะบะฐ**:
```go
// ะฃะฟัะพััะฝะฝะพ
const preemptionInterval = 10 * time.Millisecond

func sysmon() {
    for {
        // ะัะพะฒะตััะตะผ ะฒัะต P
        for _, pp := range allp {
            if pp.m != nil && pp.m.curg != nil {
                gp := pp.m.curg

                // ะัะปะธ G ะฒัะฟะพะปะฝัะตััั > 10ms - ะฒััะตัะฝัะตะผ
                if now - gp.schedtime > preemptionInterval {
                    preemptone(pp)
                }
            }
        }

        time.Sleep(sysmonInterval)
    }
}
```

### Cooperative vs Preemptive

**C# (ะดะพ .NET 6)**:
```csharp
// Cooperative - ะทะฐะดะฐัะฐ ะดะพะปะถะฝะฐ ัะฐะผะฐ yield
async Task LongRunning()
{
    for (int i = 0; i < 1000000; i++)
    {
        // ะฏะฒะฝัะน yield
        if (i % 1000 == 0)
            await Task.Yield(); // ะะฐัะผ ThreadPool ะฟะตัะตะบะปััะธัััั
    }
}
```

**Go (1.14+)**:
```go
// ะะปะฐะฝะธัะพะฒัะธะบ ัะฐะผ ะฟัะตัะฒัั ัะตัะตะท 10ms
func longRunning() {
    for i := 0; i < 1000000; i++ {
        // ะะต ะฝัะถะตะฝ ัะฒะฝัะน yield
        _ = i * 2
    }
}
```

### Safe points

ะะตัะผะพััั ะฝะฐ signal-based preemption, ะตััั ะผะตััะฐ, ะณะดะต ะฒััะตัะฝะตะฝะธะต ะฑะตะทะพะฟะฐัะฝะตะต:

```go
// Safe points:
// 1. Function calls
func work() {
    doSomething() // Safe point
}

// 2. Channel operations
ch := make(chan int)
ch <- 42 // Safe point
val := <-ch // Safe point

// 3. Memory allocations
data := make([]int, 1000) // Safe point
```

---

## GOMAXPROCS

`GOMAXPROCS` ะพะฟัะตะดะตะปัะตั ะบะพะปะธัะตััะฒะพ P (ะปะพะณะธัะตัะบะธั ะฟัะพัะตััะพัะพะฒ).

### ะะฝะฐัะตะฝะธะต ะฟะพ ัะผะพะปัะฐะฝะธั

```go
import "runtime"

func main() {
    // ะะพ ัะผะพะปัะฐะฝะธั = ะบะพะปะธัะตััะฒะพ CPU cores
    fmt.Println(runtime.GOMAXPROCS(0)) // 8 (ะฝะฐ 8-core ะผะฐัะธะฝะต)
}
```

### ะะฐัััะพะนะบะฐ

```go
// ะัะพะณัะฐะผะผะฝะพ
runtime.GOMAXPROCS(4) // ะฃััะฐะฝะพะฒะธัั 4 P

// ะงะตัะตะท ะฟะตัะตะผะตะฝะฝัั ะพะบััะถะตะฝะธั
// GOMAXPROCS=4 go run main.go
```

### ะะปะธัะฝะธะต ะฝะฐ ะฟัะพะธะทะฒะพะดะธัะตะปัะฝะพััั

**CPU-bound ะทะฐะดะฐัะธ**:
```go
// GOMAXPROCS = ะบะพะปะธัะตััะฒะพ cores - ะพะฟัะธะผะฐะปัะฝะพ
func cpuBound() {
    for i := 0; i < 1e9; i++ {
        _ = i * i
    }
}
```

**I/O-bound ะทะฐะดะฐัะธ**:
```go
// GOMAXPROCS ะผะพะถะตั ะฑััั > cores
// ะะพัััะธะฝั ะฑะปะพะบะธัััััั ะฝะฐ I/O, ะพัะฒะพะฑะพะถะดะฐั M
func ioBound() {
    resp, _ := http.Get("https://example.com")
    defer resp.Body.Close()
}
```

### ะกัะฐะฒะฝะตะฝะธะต ั .NET

**C#**:
```csharp
// .NET ThreadPool
ThreadPool.SetMinThreads(minWorker, minIO);
ThreadPool.SetMaxThreads(maxWorker, maxIO);

// ะะพ ัะผะพะปัะฐะฝะธั:
// Min = ะบะพะปะธัะตััะฒะพ cores
// Max = 32767 (ัะตะพัะตัะธัะตัะบะธ)
```

**Go**:
```go
// GOMAXPROCS - ะบะพะปะธัะตััะฒะพ ะฟะฐัะฐะปะปะตะปัะฝัั ะธัะฟะพะปะฝะธัะตะปะตะน
// ะะต ะพะณัะฐะฝะธัะธะฒะฐะตั ะบะพะปะธัะตััะฒะพ M (threads)
// M ัะพะทะดะฐัััั ะฟะพ ะฝะตะพะฑัะพะดะธะผะพััะธ (ะดะพ 10000)
```

### ะะตะบะพะผะตะฝะดะฐัะธะธ

โ **ะััะฐะฒััะต ะฟะพ ัะผะพะปัะฐะฝะธั** (= cores) ะดะปั ะฑะพะปััะธะฝััะฒะฐ ัะปััะฐะตะฒ

โ๏ธ **ะฃะฒะตะปะธัััะต**, ะตัะปะธ:
- ะะฝะพะณะพ I/O-bound ะพะฟะตัะฐัะธะน
- ะัะฟะพะปัะทัะตัะต cgo (ะฑะปะพะบะธััะตั M)
- ะะฐะฟััะบะฐะตัะต ะฒ ะบะพะฝัะตะนะฝะตัะต ั CPU throttling

โ **ะะต ัะผะตะฝััะฐะนัะต** ะฑะตะท ะฟัะธัะธะฝั:
```go
// โ ะะปะพัะพ
runtime.GOMAXPROCS(1) // ะขะพะปัะบะพ 1 P - ะฝะตั ะฟะฐัะฐะปะปะตะปะธะทะผะฐ
```

---

## ะกัะฐะฒะฝะตะฝะธะต ั .NET ThreadPool

### ะััะธัะตะบัััะฐ

**.NET ThreadPool** (ัะฟัะพััะฝะฝะพ):
```
                Global Queue
                     โ
    โโโโโโโโโโโโโโโโโโดโโโโโโโโโโโโโโโโโ
    โ                โ                โ
Worker Thread 1  Worker Thread 2  Worker Thread N
    โ                โ                โ
Local Queue      Local Queue      Local Queue
```

**Go Scheduler**:
```
                Global Queue
                     โ
    โโโโโโโโโโโโโโโโโโดโโโโโโโโโโโโโโโโโ
    โ                โ                โ
    P0               P1               P2
    โ                โ                โ
    M0               M1               M2
    โ                โ                โ
 Goroutines      Goroutines      Goroutines
```

### ะะปััะตะฒัะต ัะฐะทะปะธัะธั

| ะัะฟะตะบั | .NET ThreadPool | Go Scheduler |
|--------|-----------------|--------------|
| **ะะพะดะตะปั** | Thread Pool | M:N scheduler |
| **ะะดะธะฝะธัะฐ** | Task ะฝะฐ Thread | Goroutine ะฝะฐ M ัะตัะตะท P |
| **ะะพะฝัะตะบัั** | ะะตั ัะฒะฝะพะณะพ | P (ะฟัะพัะตััะพั) |
| **Work-stealing** | ะะฐ (ั .NET 4) | ะะฐ (ะฐะณัะตััะธะฒะฝัะน) |
| **ะะพะปะธัะตััะฒะพ threads** | ~cores * 2-4 | ะะธะฝะฐะผะธัะตัะบะพะต (ะดะพ 10000 M) |
| **ะะปะพะบะธัะพะฒะบะฐ** | ะะปะพะบะธััะตั thread | M ะพััะพะตะดะธะฝัะตััั ะพั P |
| **Preemption** | Cooperative | Signal-based (1.14+) |

### ะัะธะผะตั: ะฑะปะพะบะธััััะธะน syscall

**C#**:
```csharp
// Syscall ะฑะปะพะบะธััะตั worker thread
await Task.Run(() =>
{
    // ะะปะพะบะธััััะธะน I/O
    using var file = File.OpenRead("large.dat");
    var buffer = new byte[1024];
    file.Read(buffer, 0, buffer.Length); // ะะปะพะบะธััะตั thread

    // ThreadPool ัะพะทะดะฐัั ะฝะพะฒัะน thread ะตัะปะธ ะฝัะถะฝะพ
});
```

**Go**:
```go
// Syscall ะฑะปะพะบะธััะตั M, ะฝะพ ะฝะต P
go func() {
    // ะะปะพะบะธััััะธะน I/O
    file, _ := os.Open("large.dat")
    defer file.Close()

    buffer := make([]byte, 1024)
    file.Read(buffer) // ะะปะพะบะธััะตั M

    // Runtime ะพััะพะตะดะธะฝัะตั M ะพั P
    // P ะฑะตััั ะดััะณะพะน M ะธ ะฟัะพะดะพะปะถะฐะตั ัะฐะฑะพัั
}()
```

### ะัะตะธะผััะตััะฒะฐ Go

1. **ะัะณะบะพััั**: ะะพัััะธะฝั ะปะตะณัะต Task (ะฝะตั boxing, ะผะตะฝััะต ะฝะฐะบะปะฐะดะฝัั ัะฐััะพะดะพะฒ)
2. **ะะฐัััะฐะฑะธััะตะผะพััั**: ะะธะปะปะธะพะฝั ะณะพัััะธะฝ vs ัััััะธ threads
3. **ะะพะฝัะตะบัั P**: ะะตัะธัะพะฒะฐะฝะธะต ะฐะปะปะพะบะฐัะธะน, ะปัััะฐั locality
4. **ะะดะฐะฟัะธะฒะฝะพััั**: M ัะพะทะดะฐัััั/ัะฝะธััะพะถะฐัััั ะฟะพ ะฝะตะพะฑัะพะดะธะผะพััะธ

---

## ะขัะฐััะธัะพะฒะบะฐ ะธ ะดะธะฐะณะฝะพััะธะบะฐ

### go tool trace

ะะธะทัะฐะปะธะทะฐัะธั ัะฐะฑะพัั ะฟะปะฐะฝะธัะพะฒัะธะบะฐ.

```bash
# ะะฐะฟะธัั trace
go test -trace=trace.out

# ะะปะธ ะฒ ะบะพะดะต
import "runtime/trace"

func main() {
    f, _ := os.Create("trace.out")
    defer f.Close()

    trace.Start(f)
    defer trace.Stop()

    // ะะฐั ะบะพะด
}

# ะัะพัะผะพัั trace
go tool trace trace.out
```

**ะงัะพ ะฟะพะบะฐะทัะฒะฐะตั trace**:
- ะะพัััะธะฝั ะฟะพ ะฒัะตะผะตะฝะธ
- ะะตัะตะบะปััะตะฝะธั ะผะตะถะดั G
- ะะปะพะบะธัะพะฒะบะธ ะฝะฐ ะบะฐะฝะฐะปะฐั
- GC ัะพะฑััะธั
- Syscalls

**ะัะธะผะตั ะฒัะฒะพะดะฐ**:
```
Goroutine analysis:
  Running: 4
  Runnable: 120
  Blocked: 0

Processor utilization:
  P0: 98%
  P1: 95%
  P2: 12%  โ ะัะพะฑะปะตะผะฐ: ะฟัะพััะฐะธะฒะฐะตั
  P3: 97%
```

### GODEBUG=schedtrace

ะะตัะธะพะดะธัะตัะบะฐั ะฟะตัะฐัั ััะฐัะธััะธะบะธ ะฟะปะฐะฝะธัะพะฒัะธะบะฐ.

```bash
GODEBUG=schedtrace=1000 ./myapp
```

**ะัะฒะพะด**:
```
SCHED 1000ms: gomaxprocs=4 idleprocs=0 threads=6 spinningthreads=0 idlethreads=1 runqueue=0 [0 0 0 0]
       โ         โ           โ           โ           โ               โ            โ        โ
     ะฒัะตะผั   GOMAXPROCS   ะฟัะพััะฐะธะฒะฐััะธั  ะฒัะตะณะพ M   spinning M    idle M    global RQ  local RQ (ะฟะพ P)
```

**ะะฐััะธััะพะฒะบะฐ**:
- `gomaxprocs=4`: 4 ะฟัะพัะตััะพัะฐ (P)
- `idleprocs=0`: ะฒัะต P ะทะฐะฝััั (ัะพัะพัะพ)
- `threads=6`: 6 OS threads (M)
- `runqueue=0`: global run queue ะฟัััะฐ
- `[0 0 0 0]`: local run queues (ะฒัะต ะฟัััั - ัะพัะพัะพ)

### runtime.NumGoroutine()

```go
import "runtime"

func main() {
    // ะะพะปะธัะตััะฒะพ ะฐะบัะธะฒะฝัั ะณะพัััะธะฝ
    fmt.Println("Goroutines:", runtime.NumGoroutine())

    for i := 0; i < 1000; i++ {
        go func() {
            time.Sleep(time.Hour)
        }()
    }

    fmt.Println("Goroutines:", runtime.NumGoroutine()) // ~1001
}
```

### pprof goroutine profile

```go
import _ "net/http/pprof"

func main() {
    go func() {
        http.ListenAndServe("localhost:6060", nil)
    }()

    // ะะฐั ะบะพะด
}
```

```bash
# ะัะพัะผะพัั ะณะพัััะธะฝ
go tool pprof http://localhost:6060/debug/pprof/goroutine

# ะ ะธะฝัะตัะฐะบัะธะฒะฝะพะผ ัะตะถะธะผะต
(pprof) top
Showing nodes accounting for 1000, 100% of 1000 total
      flat  flat%   sum%        cum   cum%
      500 50.00% 50.00%       500 50.00%  main.worker
      300 30.00% 80.00%       300 30.00%  net/http.(*conn).serve
      200 20.00% 100.00%      200 20.00%  time.Sleep
```

---

## ะะฟัะธะผะธะทะฐัะธั ะฟะพะด ะฟะปะฐะฝะธัะพะฒัะธะบ

### 1. ะะทะฑะตะณะฐะนัะต ัะพะทะดะฐะฝะธั ัะปะธัะบะพะผ ะผะฝะพะณะธั ะณะพัััะธะฝ

```go
// โ ะะปะพัะพ: 1 ะผะธะปะปะธะพะฝ ะณะพัััะธะฝ ะดะปั trivial ัะฐะฑะพัั
func bad() {
    for i := 0; i < 1_000_000; i++ {
        go func(n int) {
            fmt.Println(n)
        }(i)
    }
}

// โ ะฅะพัะพัะพ: worker pool
func good() {
    const workers = 100
    jobs := make(chan int, 1000)

    var wg sync.WaitGroup
    for w := 0; w < workers; w++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for job := range jobs {
                fmt.Println(job)
            }
        }()
    }

    for i := 0; i < 1_000_000; i++ {
        jobs <- i
    }
    close(jobs)
    wg.Wait()
}
```

### 2. ะะธะฝะธะผะธะทะธััะนัะต ะฑะปะพะบะธัะพะฒะบะธ

```go
// โ ะะปะพัะพ: ัะฐัััะต ะฑะปะพะบะธัะพะฒะบะธ ะฝะฐ mutex
type Counter struct {
    mu sync.Mutex
    value int
}

func (c *Counter) Inc() {
    c.mu.Lock()
    c.value++
    c.mu.Unlock() // ะะปะพะบะธััะตั ะณะพัััะธะฝั, ัะฝะธะผะฐะตั ั M
}

// โ ะัััะต: atomic ะพะฟะตัะฐัะธะธ
type Counter struct {
    value int64
}

func (c *Counter) Inc() {
    atomic.AddInt64(&c.value, 1) // ะะต ะฑะปะพะบะธััะตั
}
```

### 3. ะัะฟะพะปัะทัะนัะต buffered channels ะฟัะฐะฒะธะปัะฝะพ

```go
// โ ะะปะพัะพ: ะฝะตะฑััะตัะธะทะธัะพะฒะฐะฝะฝัะน = ะฑะปะพะบะธัะพะฒะบะธ
ch := make(chan int)

go func() {
    for i := 0; i < 1000; i++ {
        ch <- i // ะะปะพะบะธััะตััั ะฝะฐ ะบะฐะถะดะพะน ะพัะฟัะฐะฒะบะต
    }
}()

for i := 0; i < 1000; i++ {
    <-ch // ะะปะพะบะธััะตััั ะฝะฐ ะบะฐะถะดะพะผ ะฟะพะปััะตะฝะธะธ
}

// โ ะัััะต: ะฑััะตัะธะทะธัะพะฒะฐะฝะฝัะน
ch := make(chan int, 100) // ะะตะฝััะต ะฑะปะพะบะธัะพะฒะพะบ

go func() {
    for i := 0; i < 1000; i++ {
        ch <- i // ะะปะพะบะธััะตััั ัะพะปัะบะพ ะบะพะณะดะฐ ะฑััะตั ะฟะพะปะพะฝ
    }
    close(ch)
}()

for val := range ch {
    _ = val
}
```

### 4. ะะทะฑะตะณะฐะนัะต ะดะพะปะณะธั ะฒััะธัะปะตะฝะธะน ะฑะตะท yield

```go
// โ ะะปะพัะพ (ะฒ Go < 1.14): ะผะพะฝะพะฟะพะปะธะทะธััะตั P
func compute() {
    sum := 0
    for i := 0; i < 1e9; i++ {
        sum += i
    }
    return sum
}

// โ ะฅะพัะพัะพ: ะฟะตัะธะพะดะธัะตัะบะธ yield (ะดะปั Go < 1.14)
func compute() {
    sum := 0
    for i := 0; i < 1e9; i++ {
        sum += i
        if i % 1e6 == 0 {
            runtime.Gosched() // ะฏะฒะฝัะน yield
        }
    }
    return sum
}

// โ Go 1.14+: ะฝะต ะฝัะถะตะฝ ัะฒะฝัะน yield (signal-based preemption)
func compute() {
    sum := 0
    for i := 0; i < 1e9; i++ {
        sum += i
    }
    return sum
}
```

### 5. GOMAXPROCS ะดะปั ะบะพะฝัะตะนะฝะตัะพะฒ

```go
import _ "go.uber.org/automaxprocs"

// ะะฒัะพะผะฐัะธัะตัะบะธ ัััะฐะฝะฐะฒะปะธะฒะฐะตั GOMAXPROCS
// ะฝะฐ ะพัะฝะพะฒะต CPU limits ะฒ ะบะพะฝัะตะนะฝะตัะต
func main() {
    // automaxprocs ัะถะต ัััะฐะฝะพะฒะธะป ะฟัะฐะฒะธะปัะฝะพะต ะทะฝะฐัะตะฝะธะต
    // ...
}
```

---

## ะัะฐะบัะธัะตัะบะธะต ะฟัะธะผะตัั

### ะัะธะผะตั 1: ะะพะฝะธัะพัะธะฝะณ ะฟะปะฐะฝะธัะพะฒัะธะบะฐ

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func monitorScheduler(interval time.Duration) {
    ticker := time.NewTicker(interval)
    defer ticker.Stop()

    for range ticker.C {
        var stats runtime.MemStats
        runtime.ReadMemStats(&stats)

        fmt.Printf("Goroutines: %d, Threads: %d, GOMAXPROCS: %d\n",
            runtime.NumGoroutine(),
            runtime.NumCPU(),
            runtime.GOMAXPROCS(0))

        fmt.Printf("Heap: %.2f MB, Alloc: %.2f MB\n",
            float64(stats.HeapAlloc)/1024/1024,
            float64(stats.TotalAlloc)/1024/1024)

        fmt.Println("---")
    }
}

func main() {
    go monitorScheduler(2 * time.Second)

    // ะกะธะผัะปััะธั ัะฐะฑะพัั
    for i := 0; i < 100; i++ {
        go func(n int) {
            time.Sleep(time.Duration(n) * time.Second)
        }(i % 10)
    }

    time.Sleep(20 * time.Second)
}
```

### ะัะธะผะตั 2: ะะฟัะธะผะธะทะฐัะธั ั worker pool

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

type Job struct {
    ID   int
    Data int
}

type Result struct {
    JobID  int
    Result int
}

func worker(id int, jobs <-chan Job, results chan<- Result, wg *sync.WaitGroup) {
    defer wg.Done()

    for job := range jobs {
        // ะกะธะผัะปััะธั CPU-intensive ัะฐะฑะพัั
        result := 0
        for i := 0; i < job.Data; i++ {
            result += i
        }

        results <- Result{
            JobID:  job.ID,
            Result: result,
        }
    }
}

func main() {
    numWorkers := runtime.GOMAXPROCS(0) // = ะบะพะปะธัะตััะฒะพ P
    numJobs := 1000

    jobs := make(chan Job, 100)
    results := make(chan Result, 100)

    var wg sync.WaitGroup

    // ะะฐะฟััะบะฐะตะผ workers
    fmt.Printf("Starting %d workers (GOMAXPROCS=%d)\n", numWorkers, numWorkers)
    for w := 0; w < numWorkers; w++ {
        wg.Add(1)
        go worker(w, jobs, results, &wg)
    }

    // ะะฐะบััะฒะฐะตะผ results ะฟะพัะปะต ะทะฐะฒะตััะตะฝะธั ะฒัะตั workers
    go func() {
        wg.Wait()
        close(results)
    }()

    // ะัะฟัะฐะฒะปัะตะผ jobs
    start := time.Now()
    go func() {
        for i := 0; i < numJobs; i++ {
            jobs <- Job{ID: i, Data: 10000}
        }
        close(jobs)
    }()

    // ะกะพะฑะธัะฐะตะผ ัะตะทัะปััะฐัั
    count := 0
    for range results {
        count++
    }

    elapsed := time.Since(start)
    fmt.Printf("Processed %d jobs in %v\n", count, elapsed)
    fmt.Printf("Throughput: %.2f jobs/sec\n", float64(count)/elapsed.Seconds())
}
```

### ะัะธะผะตั 3: ะกัะฐะฒะฝะตะฝะธะต GOMAXPROCS

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

func cpuIntensiveWork(n int) int {
    result := 0
    for i := 0; i < n; i++ {
        result += i
    }
    return result
}

func benchmark(numGoroutines, gomaxprocs int) time.Duration {
    runtime.GOMAXPROCS(gomaxprocs)

    var wg sync.WaitGroup
    start := time.Now()

    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            cpuIntensiveWork(1000000)
        }()
    }

    wg.Wait()
    return time.Since(start)
}

func main() {
    numCPU := runtime.NumCPU()
    fmt.Printf("CPU cores: %d\n\n", numCPU)

    goroutines := []int{10, 100, 1000}
    gomaxprocsValues := []int{1, numCPU / 2, numCPU, numCPU * 2}

    for _, g := range goroutines {
        fmt.Printf("=== %d goroutines ===\n", g)
        for _, p := range gomaxprocsValues {
            duration := benchmark(g, p)
            fmt.Printf("GOMAXPROCS=%d: %v\n", p, duration)
        }
        fmt.Println()
    }
}
```

---

## ะงะตะบ-ะปะธัั

ะะพัะปะต ะธะทััะตะฝะธั ััะพะณะพ ัะฐะทะดะตะปะฐ ะฒั ะดะพะปะถะฝั ะฟะพะฝะธะผะฐัั:

- [ ] ะััะธัะตะบัััั GMP (Goroutine, Machine, Processor)
- [ ] ะะฐะบ ัะฐะฑะพัะฐะตั work-stealing ะฐะปะณะพัะธัะผ
- [ ] ะะฐะทะฝะธัั ะผะตะถะดั cooperative ะธ preemptive ะฟะปะฐะฝะธัะพะฒะฐะฝะธะตะผ
- [ ] ะะปะธัะฝะธะต GOMAXPROCS ะฝะฐ ะฟัะพะธะทะฒะพะดะธัะตะปัะฝะพััั
- [ ] ะัะปะธัะธั ะพั .NET ThreadPool
- [ ] ะะฐะบ ะธัะฟะพะปัะทะพะฒะฐัั go tool trace ะดะปั ะดะธะฐะณะฝะพััะธะบะธ
- [ ] ะะฐะบ ะพะฟัะธะผะธะทะธัะพะฒะฐัั ะบะพะด ะฟะพะด ะฟะปะฐะฝะธัะพะฒัะธะบ
- [ ] ะะพะณะดะฐ ัะพะทะดะฐะฒะฐัั worker pool ะฒะผะตััะพ ะผะธะปะปะธะพะฝะพะฒ ะณะพัััะธะฝ

---

## ะกะปะตะดัััะธะต ัะฐะณะธ

ะะตัะตัะพะดะธัะต ะบ [2.3 ะกะฑะพัะบะฐ ะผััะพัะฐ (GC)](03_gc.md) ะดะปั ะฟะพะฝะธะผะฐะฝะธั ัะพะณะพ, ะบะฐะบ Go ัะฟัะฐะฒะปัะตั ะฟะฐะผัััั.

---

**ะะพะฟัะพัั?** ะัะบัะพะน issue ะฝะฐ [GitHub](https://github.com/AlexandrTolstuhin/csharp-to-go/issues)

[โ ะะฐะทะฐะด: ะะพัััะธะฝั ะธ ะบะฐะฝะฐะปั](01_goroutines_channels.md) | [ะะฟะตััะด: ะกะฑะพัะบะฐ ะผััะพัะฐ โ](03_gc.md)
