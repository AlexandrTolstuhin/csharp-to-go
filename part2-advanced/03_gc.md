# 2.3 –°–±–æ—Ä–∫–∞ –º—É—Å–æ—Ä–∞ (GC)

## –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ
- [–í–≤–µ–¥–µ–Ω–∏–µ](#–≤–≤–µ–¥–µ–Ω–∏–µ)
- [–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ GC –≤ Go vs .NET](#–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞-gc-–≤-go-vs-net)
- [Tri-Color Mark-and-Sweep –∞–ª–≥–æ—Ä–∏—Ç–º](#tri-color-mark-and-sweep-–∞–ª–≥–æ—Ä–∏—Ç–º)
- [Write Barriers –∏ concurrent GC](#write-barriers-–∏-concurrent-gc)
- [GOGC –∏ GOMEMLIMIT](#gogc-–∏-gomemlimit)
- [Escape Analysis: Stack vs Heap](#escape-analysis-stack-vs-heap)
- [–ü—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞](#–ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ-–∏-–¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞)
- [–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–æ–¥ GC](#–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è-–ø–æ–¥-gc)
- [sync.Pool –∏ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤](#syncpool-–∏-–ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ-–æ–±—ä–µ–∫—Ç–æ–≤)
- [–ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ—Ä—ã](#–ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ-–ø—Ä–∏–º–µ—Ä—ã)
- [–ß–µ–∫-–ª–∏—Å—Ç](#—á–µ–∫-–ª–∏—Å—Ç)

---

## –í–≤–µ–¥–µ–Ω–∏–µ

–°–±–æ—Ä–∫–∞ –º—É—Å–æ—Ä–∞ –≤ Go —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω–∞ —Å —Ñ–æ–∫—É—Å–æ–º –Ω–∞ **–Ω–∏–∑–∫–∏–µ –ø–∞—É–∑—ã** (< 1ms) –∏ **–ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–æ—Å—Ç—å**, —á—Ç–æ –∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –≤—ã—Å–æ–∫–æ–Ω–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤. –§–∏–ª–æ—Å–æ—Ñ–∏—è Go GC —Ä–∞–¥–∏–∫–∞–ª—å–Ω–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç .NET.

> üí° **–î–ª—è C# —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤**: –í .NET GC –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è **throughput** (–ø—Ä–æ–ø—É—Å–∫–Ω–æ–π —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏) —Å –ø–∞—É–∑–∞–º–∏ –¥–æ 100ms+. –í Go GC –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è **low latency** —Å –ø–∞—É–∑–∞–º–∏ < 1ms.

### –ö–ª—é—á–µ–≤—ã–µ –æ—Ç–ª–∏—á–∏—è

| –ê—Å–ø–µ–∫—Ç | .NET GC | Go GC |
|--------|---------|-------|
| **–ê–ª–≥–æ—Ä–∏—Ç–º** | Generational (Gen0/1/2) | Tri-color mark-and-sweep |
| **–ü–æ–∫–æ–ª–µ–Ω–∏—è** | 3 –ø–æ–∫–æ–ª–µ–Ω–∏—è | –ù–µ—Ç –ø–æ–∫–æ–ª–µ–Ω–∏–π |
| **–ü–∞—É–∑—ã** | 10-100ms (full GC) | < 1ms (—Ü–µ–ª–µ–≤–∞—è –º–µ—Ç—Ä–∏–∫–∞) |
| **Concurrent** | –ß–∞—Å—Ç–∏—á–Ω–æ (background GC) | –ü–æ–ª–Ω–æ—Å—Ç—å—é concurrent |
| **Compaction** | –ï—Å—Ç—å (Gen0/1) | –ù–µ—Ç (fragmentation –≤–æ–∑–º–æ–∂–Ω–∞) |
| **–¶–µ–ª—å** | Throughput | Low latency |
| **–ù–∞—Å—Ç—Ä–æ–π–∫–∞** | –ú–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ | GOGC, GOMEMLIMIT |

---

## –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ GC –≤ Go vs .NET

### .NET GC (–¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞)

**C#** (Generational GC):
```csharp
// .NET GC —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –ø–æ–∫–æ–ª–µ–Ω–∏—è–º–∏
// Gen0: –∫–æ—Ä–æ—Ç–∫–æ–∂–∏–≤—É—â–∏–µ –æ–±—ä–µ–∫—Ç—ã (< 1MB –æ–±—ã—á–Ω–æ)
// Gen1: —Å—Ä–µ–¥–Ω–µ–π –ø—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
// Gen2: –¥–æ–ª–≥–æ–∂–∏–≤—É—â–∏–µ –æ–±—ä–µ–∫—Ç—ã + LOH (Large Object Heap)

var list = new List<int>(); // –ê–ª–ª–æ–∫–∞—Ü–∏—è –≤ Gen0

// –ü–æ—Å–ª–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö Gen0 —Å–±–æ—Ä–æ–∫ –≤—ã–∂–∏–≤—à–∏–π –æ–±—ä–µ–∫—Ç –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –≤ Gen1
// –ó–∞—Ç–µ–º –≤ Gen2

// –ü–æ–ª–Ω–∞—è —Å–±–æ—Ä–∫–∞ (Gen2 + LOH) –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å 100ms+
GC.Collect(2, GCCollectionMode.Forced); // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Å–±–æ—Ä–∫–∞
```

**–ü—Ä–æ–±–ª–µ–º—ã .NET GC**:
- **Stop-the-World –ø–∞—É–∑—ã** –ø—Ä–∏ –ø–æ–ª–Ω–æ–π —Å–±–æ—Ä–∫–µ Gen2
- **Unpredictable latency** ‚Äî —Å–ª–æ–∂–Ω–æ –ø—Ä–µ–¥—Å–∫–∞–∑–∞—Ç—å, –∫–æ–≥–¥–∞ –±—É–¥–µ—Ç –ø–∞—É–∑–∞
- **Large Object Heap** –Ω–µ –∫–æ–º–ø–∞–∫—Ç–∏—Ä—É–µ—Ç—Å—è ‚Üí fragmentation

### Go GC (Tri-Color Mark-and-Sweep)

**Go** (Concurrent Mark-Sweep):
```go
// Go GC –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ø–æ–∫–æ–ª–µ–Ω–∏—è
// –í—Å–µ –æ–±—ä–µ–∫—Ç—ã –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –æ–¥–∏–Ω–∞–∫–æ–≤–æ
// Concurrent —Å–±–æ—Ä–∫–∞ —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –ø–∞—É–∑–∞–º–∏

package main

import (
    "fmt"
    "runtime"
    "runtime/debug"
)

func main() {
    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ GC
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    fmt.Printf("–ê–ª–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ: %d MB\n", m.Alloc/1024/1024)
    fmt.Printf("–í—Å–µ–≥–æ –∞–ª–ª–æ–∫–∞—Ü–∏–π: %d MB\n", m.TotalAlloc/1024/1024)
    fmt.Printf("–°–∏—Å—Ç–µ–º–Ω–∞—è –ø–∞–º—è—Ç—å: %d MB\n", m.Sys/1024/1024)
    fmt.Printf("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ GC: %d\n", m.NumGC)
    fmt.Printf("–ü–æ—Å–ª–µ–¥–Ω—è—è –ø–∞—É–∑–∞ GC: %v\n", m.PauseNs[(m.NumGC+255)%256])

    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ GC
    debug.SetGCPercent(100) // GOGC=100 (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)

    // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ GC (—Ä–µ–¥–∫–æ –Ω—É–∂–Ω–æ –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ)
    runtime.GC()
}
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ Go GC**:
- ‚úÖ **Predictable latency** ‚Äî –ø–∞—É–∑—ã < 1ms
- ‚úÖ **Concurrent** ‚Äî —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ —Å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º
- ‚úÖ **–ü—Ä–æ—Å—Ç–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞** ‚Äî –¥–≤–∞ –æ—Å–Ω–æ–≤–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–∞

**–ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏**:
- ‚ùå **–ù–µ—Ç –∫–æ–º–ø–∞–∫—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏** ‚Äî –≤–æ–∑–º–æ–∂–Ω–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞—Ü–∏—è –ø–∞–º—è—Ç–∏
- ‚ùå **–ë–æ–ª—å—à–µ CPU overhead** ‚Äî –∏–∑-–∑–∞ concurrent —Ä–∞–±–æ—Ç—ã
- ‚ùå **–ù–µ—Ç –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –¥–ª—è –∫–æ—Ä–æ—Ç–∫–æ–∂–∏–≤—É—â–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤** (–∫–∞–∫ Gen0 –≤ .NET)

---

## Tri-Color Mark-and-Sweep –∞–ª–≥–æ—Ä–∏—Ç–º

### –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç

Go GC –∏—Å–ø–æ–ª—å–∑—É–µ—Ç **—Ç—Ä–∏ —Ü–≤–µ—Ç–∞** –¥–ª—è –º–∞—Ä–∫–∏—Ä–æ–≤–∫–∏ –æ–±—ä–µ–∫—Ç–æ–≤:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  White  ‚îÇ ‚Üê –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –º–µ—Ä—Ç–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã (–±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Grey   ‚îÇ ‚Üê –ñ–∏–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –ø—Ä–æ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Black  ‚îÇ ‚Üê –ñ–∏–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã, —É–∂–µ –ø—Ä–æ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### –§–∞–∑—ã GC

```go
// –ü—Å–µ–≤–¥–æ–∫–æ–¥ —Ä–∞–±–æ—Ç—ã Go GC

// 1. SWEEP TERMINATION (STW ~ 10-30Œºs)
//    - –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø—Ä–µ–¥—ã–¥—É—â–µ–π —Ñ–∞–∑—ã sweep
//    - –í–∫–ª—é—á–µ–Ω–∏–µ write barriers

// 2. MARK (concurrent)
//    - –í—Å–µ –æ–±—ä–µ–∫—Ç—ã –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ WHITE
//    - –ö–æ—Ä–Ω–µ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã ‚Üí GREY
//    - –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ GREY ‚Üí BLACK, –∏—Ö –ø–æ—Ç–æ–º–∫–∏ ‚Üí GREY
//    - –†–∞–±–æ—Ç–∞–µ—Ç –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ —Å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º (25% CPU)

// 3. MARK TERMINATION (STW ~ 60-90Œºs)
//    - –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –º–∞—Ä–∫–∏—Ä–æ–≤–∫–∏
//    - –í—ã–∫–ª—é—á–µ–Ω–∏–µ write barriers
//    - –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ sweep

// 4. SWEEP (concurrent)
//    - –£–¥–∞–ª–µ–Ω–∏–µ WHITE –æ–±—ä–µ–∫—Ç–æ–≤
//    - –í–æ–∑–≤—Ä–∞—Ç –ø–∞–º—è—Ç–∏ –≤ –∞–ª–ª–æ–∫–∞—Ç–æ—Ä
```

### –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å .NET

**C#** (Mark-Compact):
```csharp
// .NET GC Gen0 —Å–±–æ—Ä–∫–∞:
// 1. Stop-the-World
// 2. Mark –∂–∏–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
// 3. Compact (–ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –≤ –Ω–∞—á–∞–ª–æ –∫—É—á–∏)
// 4. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π
// 5. Resume

// –ü–∞—É–∑–∞: 1-5ms –¥–ª—è Gen0, 10-100ms+ –¥–ª—è Gen2
```

**Go** (Mark-Sweep):
```go
// Go GC:
// 1. STW (10-30Œºs) - sweep termination
// 2. Concurrent Mark (—Ä–∞–±–æ—Ç–∞–µ—Ç –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ)
// 3. STW (60-90Œºs) - mark termination
// 4. Concurrent Sweep

// –û–±—â–∞—è STW –ø–∞—É–∑–∞: < 1ms
```

### –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è

```
.NET GC (Generational):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Gen0  ‚îÇ  Gen1  ‚îÇ     Gen2     ‚îÇ
‚îÇ (fast) ‚îÇ (mid)  ‚îÇ    (slow)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚Üì         ‚Üì          ‚Üì
  1-5ms    5-20ms    10-100ms+

Go GC (Concurrent):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Concurrent Mark/Sweep     ‚îÇ
‚îÇ     (—Ä–∞–±–æ—Ç–∞–µ—Ç –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
STW: 10-30Œºs + 60-90Œºs = < 1ms
```

---

## Write Barriers –∏ concurrent GC

### –ü—Ä–æ–±–ª–µ–º–∞ concurrent GC

–ö–æ–≥–¥–∞ GC —Ä–∞–±–æ—Ç–∞–µ—Ç concurrent (–ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ —Å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º), –≤–æ–∑–Ω–∏–∫–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º–∞:

```go
// –ü—Ä–æ–±–ª–µ–º–∞: –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∏–∑–º–µ–Ω—è–µ—Ç –≥—Ä–∞—Ñ –æ–±—ä–µ–∫—Ç–æ–≤ –≤–æ –≤—Ä–µ–º—è –º–∞—Ä–∫–∏—Ä–æ–≤–∫–∏

// –î–æ GC:
// A (black) ‚Üí B (white)

// –í–æ –≤—Ä–µ–º—è GC –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–µ–ª–∞–µ—Ç:
// A.field = C  // C –±—ã–ª white, –Ω–µ –æ—Ç–º–∞—Ä–∫–∏—Ä–æ–≤–∞–Ω
// B.field = nil

// –†–µ–∑—É–ª—å—Ç–∞—Ç: C –º–æ–∂–µ—Ç –±—ã—Ç—å —É–¥–∞–ª–µ–Ω, —Ö–æ—Ç—è –æ–Ω –∂–∏–≤–æ–π!
```

### Write Barriers

**Write barrier** ‚Äî —ç—Ç–æ –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –≤—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º –ø—Ä–∏ –∑–∞–ø–∏—Å–∏ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π:

```go
// –ü—Å–µ–≤–¥–æ–∫–æ–¥ write barrier –≤ Go

func writePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    // –ï—Å–ª–∏ GC –∞–∫—Ç–∏–≤–µ–Ω –∏ –æ–±—ä–µ–∫—Ç black –ø—ã—Ç–∞–µ—Ç—Å—è —É–∫–∞–∑–∞—Ç—å –Ω–∞ white
    if gcActive && isBlack(slot) && isWhite(ptr) {
        // –ó–∞–∫—Ä–∞—Å–∏—Ç—å white –æ–±—ä–µ–∫—Ç –≤ grey
        shade(ptr)
    }
    *slot = ptr // –†–µ–∞–ª—å–Ω–∞—è –∑–∞–ø–∏—Å—å
}
```

**–°—Ç–æ–∏–º–æ—Å—Ç—å write barriers**:
```go
// Write barriers –¥–æ–±–∞–≤–ª—è—é—Ç overhead –∫ –∑–∞–ø–∏—Å—è–º —É–∫–∞–∑–∞—Ç–µ–ª–µ–π
// –ù–æ —Ä–∞–±–æ—Ç–∞—é—Ç —Ç–æ–ª—å–∫–æ –≤–æ –≤—Ä–µ–º—è GC (–Ω–µ –≤—Å–µ–≥–¥–∞)

// –ü—Ä–∏–º–µ—Ä–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å:
// –ë–µ–∑ GC: 1-2 CPU —Ü–∏–∫–ª–∞ –Ω–∞ –∑–∞–ø–∏—Å—å —É–∫–∞–∑–∞—Ç–µ–ª—è
// –° GC:   10-20 CPU —Ü–∏–∫–ª–æ–≤ –Ω–∞ –∑–∞–ø–∏—Å—å —É–∫–∞–∑–∞—Ç–µ–ª—è

// –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –∏–∑–±–µ–≥–∞–π—Ç–µ —á–∞—Å—Ç—ã—Ö –∑–∞–ø–∏—Å–µ–π —É–∫–∞–∑–∞—Ç–µ–ª–µ–π –≤ hot path
```

### –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å .NET

**C#**:
```csharp
// .NET —Ç–∞–∫–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç write barriers –¥–ª—è concurrent GC
// –ù–æ —Ç–æ–ª—å–∫–æ –≤ background GC (Gen2)

// –°—Ç–æ–∏–º–æ—Å—Ç—å –≤ .NET –∞–Ω–∞–ª–æ–≥–∏—á–Ω–∞ Go
```

---

## GOGC –∏ GOMEMLIMIT

### GOGC (–≥–ª–∞–≤–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä)

`GOGC` –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç, **–∫–æ–≥–¥–∞** –∑–∞–ø—É—Å–∫–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–π GC:

```bash
# GOGC=100 (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
# –°–ª–µ–¥—É—é—â–∏–π GC –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è, –∫–æ–≥–¥–∞ heap –≤—ã—Ä–∞—Å—Ç–µ—Ç –Ω–∞ 100% –æ—Ç live set

# –ü—Ä–∏–º–µ—Ä:
# Live set = 100 MB (–æ–±—ä–µ–∫—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø–µ—Ä–µ–∂–∏–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â–∏–π GC)
# GOGC=100 ‚Üí —Å–ª–µ–¥—É—é—â–∏–π GC –ø—Ä–∏ heap = 200 MB
# GOGC=200 ‚Üí —Å–ª–µ–¥—É—é—â–∏–π GC –ø—Ä–∏ heap = 300 MB
# GOGC=50  ‚Üí —Å–ª–µ–¥—É—é—â–∏–π GC –ø—Ä–∏ heap = 150 MB
```

**Go** –ø—Ä–∏–º–µ—Ä:
```go
package main

import (
    "fmt"
    "runtime"
    "runtime/debug"
)

func demonstrateGOGC() {
    // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ GOGC –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ
    oldGOGC := debug.SetGCPercent(200) // –£–¥–≤–æ–∏—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–∂–¥—É GC
    fmt.Printf("–°—Ç–∞—Ä—ã–π GOGC: %d\n", oldGOGC)

    // –ò–ª–∏ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è:
    // GOGC=200 go run main.go

    // –û—Ç–∫–ª—é—á–∏—Ç—å GC (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ä–µ–¥–∫–æ, –¥–ª—è —Ç–µ—Å—Ç–æ–≤)
    debug.SetGCPercent(-1)

    // –í–µ—Ä–Ω—É—Ç—å –æ–±—Ä–∞—Ç–Ω–æ
    debug.SetGCPercent(100)
}

func demonstrateMemoryTrade() {
    // Trade-off: –±–æ–ª—å—à–µ GOGC ‚Üí –±–æ–ª—å—à–µ –ø–∞–º—è—Ç–∏, –º–µ–Ω—å—à–µ CPU –Ω–∞ GC

    // GOGC=100 (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é):
    // - –°—Ä–µ–¥–Ω–∏–π —Ä–∞—Å—Ö–æ–¥ –ø–∞–º—è—Ç–∏
    // - –°—Ä–µ–¥–Ω–∏–π CPU –Ω–∞ GC (~1-5%)

    // GOGC=200:
    // - –í–¥–≤–æ–µ –±–æ–ª—å—à–µ –ø–∞–º—è—Ç–∏
    // - –í–¥–≤–æ–µ –º–µ–Ω—å—à–µ CPU –Ω–∞ GC

    // GOGC=50:
    // - –ú–µ–Ω—å—à–µ –ø–∞–º—è—Ç–∏
    // - –ë–æ–ª—å—à–µ CPU –Ω–∞ GC

    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    fmt.Printf("Live heap: %d MB\n", m.Alloc/1024/1024)
    fmt.Printf("Sys memory: %d MB\n", m.Sys/1024/1024)
    fmt.Printf("GC cycles: %d\n", m.NumGC)
}
```

### GOMEMLIMIT (Go 1.19+)

**–ñ–µ—Å—Ç–∫–∏–π –ª–∏–º–∏—Ç –ø–∞–º—è—Ç–∏** (–∞–Ω–∞–ª–æ–≥ GC.MemoryLimit –≤ .NET):

```go
package main

import (
    "fmt"
    "runtime/debug"
)

func demonstrateMemLimit() {
    // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ª–∏–º–∏—Ç–∞ –ø–∞–º—è—Ç–∏: 2 GB
    debug.SetMemoryLimit(2 * 1024 * 1024 * 1024)

    // –ò–ª–∏ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è:
    // GOMEMLIMIT=2GiB go run main.go

    // –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç:
    // - GC –±—É–¥–µ—Ç –∑–∞–ø—É—Å–∫–∞—Ç—å—Å—è —á–∞—â–µ, –µ—Å–ª–∏ –ø—Ä–∏–±–ª–∏–∂–∞–µ–º—Å—è –∫ –ª–∏–º–∏—Ç—É
    // - –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç OOM –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞—Ö —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–π –ø–∞–º—è—Ç—å—é

    // –ü–æ–ª–µ–∑–Ω–æ –≤ Kubernetes:
    // GOMEMLIMIT=1900MiB (–µ—Å–ª–∏ pod limit = 2GB)
}
```

### –°—Ä–∞–≤–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞

| –ü–∞—Ä–∞–º–µ—Ç—Ä | –ß—Ç–æ –¥–µ–ª–∞–µ—Ç | –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å |
|----------|------------|-------------------|
| `GOGC=100` | –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é (2x –ø–∞–º—è—Ç–∏) | –ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ —Å–ª—É—á–∞–µ–≤ |
| `GOGC=200` | –ú–µ–Ω—å—à–µ GC, –±–æ–ª—å—à–µ –ø–∞–º—è—Ç–∏ | CPU-bound, –º–Ω–æ–≥–æ RAM |
| `GOGC=50` | –ë–æ–ª—å—à–µ GC, –º–µ–Ω—å—à–µ –ø–∞–º—è—Ç–∏ | Memory-constrained |
| `GOMEMLIMIT` | –ñ–µ—Å—Ç–∫–∏–π –ª–∏–º–∏—Ç –ø–∞–º—è—Ç–∏ | –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã, Cloud |

**C# –∞–Ω–∞–ª–æ–≥–∏**:
```csharp
// .NET –Ω–µ –∏–º–µ–µ—Ç –ø—Ä—è–º–æ–≥–æ –∞–Ω–∞–ª–æ–≥–∞ GOGC
// –ù–æ –µ—Å—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:

// Workstation GC vs Server GC
<ServerGarbageCollection>true</ServerGarbageCollection>

// Concurrent GC
<ConcurrentGarbageCollection>true</ConcurrentGarbageCollection>

// GC Heap Count (Go 1.19+)
<GCHeapCount>4</GCHeapCount>

// Memory limit (.NET 6+)
GC.MemoryLimit = 2_000_000_000; // –ê–Ω–∞–ª–æ–≥ GOMEMLIMIT
```

---

## Escape Analysis: Stack vs Heap

### –ß—Ç–æ —Ç–∞–∫–æ–µ Escape Analysis

–ö–æ–º–ø–∏–ª—è—Ç–æ—Ä Go –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç, **–≥–¥–µ** —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é:
- **Stack** ‚Äî –±—ã—Å—Ç—Ä–æ, –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—á–∏—â–∞–µ—Ç—Å—è –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏
- **Heap** ‚Äî –º–µ–¥–ª–µ–Ω–Ω–æ, —Ç—Ä–µ–±—É–µ—Ç GC –¥–ª—è –æ—á–∏—Å—Ç–∫–∏

> üí° **–î–ª—è C# —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤**: –í C# –≤—Å–µ reference types –≤—Å–µ–≥–¥–∞ –≤ –∫—É—á–µ. –í Go –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä —Å–∞–º —Ä–µ—à–∞–µ—Ç, –≥–¥–µ —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –æ–±—ä–µ–∫—Ç, –¥–∞–∂–µ –µ—Å–ª–∏ —ç—Ç–æ —É–∫–∞–∑–∞—Ç–µ–ª—å.

### –ü—Ä–∞–≤–∏–ª–∞ Escape Analysis

```go
package main

import "fmt"

// ‚úÖ –ù–ï escape: –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ
func noEscape1() int {
    x := 42
    return x // x –Ω–∞ —Å—Ç–µ–∫–µ
}

// ‚úÖ –ù–ï escape: –ª–æ–∫–∞–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
func noEscape2() {
    s := make([]int, 100) // s –Ω–∞ —Å—Ç–µ–∫–µ (–µ—Å–ª–∏ –Ω–µ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π)
    _ = s
}

// ‚ùå ESCAPE: –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è —É–∫–∞–∑–∞—Ç–µ–ª—å
func escape1() *int {
    x := 42
    return &x // x escape –≤ heap (–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –Ω–∞—Ä—É–∂—É)
}

// ‚ùå ESCAPE: —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
var global *int

func escape2() {
    x := 42
    global = &x // x escape –≤ heap
}

// ‚ùå ESCAPE: –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è –≤ –≥–æ—Ä—É—Ç–∏–Ω—É
func escape3() {
    x := 42
    go func() {
        fmt.Println(x) // x escape –≤ heap (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ –¥—Ä—É–≥–æ–π –≥–æ—Ä—É—Ç–∏–Ω–µ)
    }()
}

// ‚ùå ESCAPE: —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –¥–ª—è —Å—Ç–µ–∫–∞
func escape4() {
    // –ú–∞—Å—Å–∏–≤—ã > ~64KB –æ–±—ã—á–Ω–æ escape –≤ heap
    var huge [100000]int
    _ = huge // escape –≤ heap
}

// ‚ùå ESCAPE: –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
func escape5() {
    x := 42
    fmt.Println(x) // x escape –≤ heap (fmt.Println –ø—Ä–∏–Ω–∏–º–∞–µ—Ç interface{})
}
```

### –ü—Ä–æ–≤–µ—Ä–∫–∞ escape analysis

```bash
# –ö–æ–º–ø–∏–ª—è—Ü–∏—è —Å –≤—ã–≤–æ–¥–æ–º escape analysis
go build -gcflags="-m -m" main.go

# –ü—Ä–∏–º–µ—Ä –≤—ã–≤–æ–¥–∞:
# ./main.go:10:2: x escapes to heap
# ./main.go:10:2:   flow: ~r0 = &x
# ./main.go:9:6: moved to heap: x
```

**Go** –ø—Ä–∏–º–µ—Ä —Å –∞–Ω–∞–ª–∏–∑–æ–º:
```go
package main

import "fmt"

func stackAllocation() {
    // –ê–Ω–∞–ª–∏–∑ –ø–æ–∫–∞–∂–µ—Ç: "does not escape"
    x := 42
    y := x * 2
    _ = y
}

func heapAllocation() *int {
    // –ê–Ω–∞–ª–∏–∑ –ø–æ–∫–∞–∂–µ—Ç: "moved to heap: x"
    x := 42
    return &x
}

func interfaceEscape() {
    // –ê–Ω–∞–ª–∏–∑ –ø–æ–∫–∞–∂–µ—Ç: "x escapes to heap"
    x := 42
    fmt.Println(x) // interface{} –≤—ã–∑—ã–≤–∞–µ—Ç escape
}

func main() {
    stackAllocation()  // –ë—ã—Å—Ç—Ä–æ, –±–µ–∑ GC
    _ = heapAllocation() // –ú–µ–¥–ª–µ–Ω–Ω–æ, —Ç—Ä–µ–±—É–µ—Ç GC
    interfaceEscape()   // Escape –∏–∑-–∑–∞ interface{}
}
```

### –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å C#

**C#**:
```csharp
// –í C# –≤—Å–µ reference types –≤ –∫—É—á–µ, value types –Ω–∞ —Å—Ç–µ–∫–µ (–µ—Å–ª–∏ –ª–æ–∫–∞–ª—å–Ω—ã–µ)

public class Example
{
    // –í—Å–µ–≥–¥–∞ –≤ –∫—É—á–µ
    public int[] HeapArray() => new int[100];

    // –°—Ç–µ–∫ (value type)
    public int StackValue() => 42;

    // ref struct (C# 7.2+) - —Ç–æ–ª—å–∫–æ —Å—Ç–µ–∫
    public ref struct StackOnlyStruct
    {
        public Span<int> Data;
    }
}

// .NET —Ç–∞–∫–∂–µ –∏–º–µ–µ—Ç Span<T> –∏ stackalloc –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π
Span<int> stack = stackalloc int[100]; // –ù–∞ —Å—Ç–µ–∫–µ!
```

**Go –±–æ–ª–µ–µ –≥–∏–±–∫–∏–π**:
```go
// Go –º–æ–∂–µ—Ç —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –¥–∞–∂–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ —Å—Ç–µ–∫–µ
func flexible() {
    // –£–∫–∞–∑–∞—Ç–µ–ª—å, –Ω–æ –ù–ï escape ‚Üí —Å—Ç–µ–∫
    p := &struct{ x int }{42}
    _ = p.x // –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ
    // p –Ω–∞ —Å—Ç–µ–∫–µ, –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ &
}
```

---

## –ü—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞

### runtime.MemStats

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func printMemStats() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    fmt.Printf("=== Memory Stats ===\n")
    fmt.Printf("Alloc      = %v MB\n", bToMb(m.Alloc))
    fmt.Printf("TotalAlloc = %v MB\n", bToMb(m.TotalAlloc))
    fmt.Printf("Sys        = %v MB\n", bToMb(m.Sys))
    fmt.Printf("NumGC      = %v\n", m.NumGC)
    fmt.Printf("HeapAlloc  = %v MB\n", bToMb(m.HeapAlloc))
    fmt.Printf("HeapSys    = %v MB\n", bToMb(m.HeapSys))
    fmt.Printf("HeapIdle   = %v MB\n", bToMb(m.HeapIdle))
    fmt.Printf("HeapInuse  = %v MB\n", bToMb(m.HeapInuse))
    fmt.Printf("HeapReleased = %v MB\n", bToMb(m.HeapReleased))

    // –ü–∞—É–∑—ã GC
    fmt.Printf("PauseTotal = %v ms\n", float64(m.PauseTotalNs)/1e6)
    fmt.Printf("Last Pause = %v Œºs\n", m.PauseNs[(m.NumGC+255)%256]/1000)
}

func bToMb(b uint64) uint64 {
    return b / 1024 / 1024
}

func main() {
    printMemStats()

    // –°–æ–∑–¥–∞–µ–º –Ω–∞–≥—Ä—É–∑–∫—É
    data := make([][]byte, 0)
    for i := 0; i < 100; i++ {
        data = append(data, make([]byte, 1024*1024)) // 1 MB
    }

    time.Sleep(100 * time.Millisecond)
    printMemStats()

    // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º
    data = nil
    runtime.GC()
    time.Sleep(100 * time.Millisecond)
    printMemStats()
}
```

### pprof –¥–ª—è GC –∞–Ω–∞–ª–∏–∑–∞

```go
package main

import (
    "fmt"
    "log"
    "net/http"
    _ "net/http/pprof" // –ò–º–ø–æ—Ä—Ç –¥–ª—è side-effect
    "time"
)

func main() {
    // –ó–∞–ø—É—Å–∫ pprof HTTP —Å–µ—Ä–≤–µ—Ä–∞
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()

    // –°–∏–º—É–ª—è—Ü–∏—è —Ä–∞–±–æ—Ç—ã
    for {
        allocateMemory()
        time.Sleep(100 * time.Millisecond)
    }
}

func allocateMemory() {
    // –ê–ª–ª–æ–∫–∞—Ü–∏—è 10 MB
    data := make([]byte, 10*1024*1024)
    _ = data
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
// 1. –ó–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—É
// 2. –û—Ç–∫—Ä—ã—Ç—å http://localhost:6060/debug/pprof/
// 3. –ò–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å CLI:
//    go tool pprof http://localhost:6060/debug/pprof/heap
//    go tool pprof http://localhost:6060/debug/pprof/allocs
```

**–ö–æ–º–∞–Ω–¥—ã pprof**:
```bash
# Heap –ø—Ä–æ—Ñ–∏–ª—å (—Ç–µ–∫—É—â–µ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏)
go tool pprof http://localhost:6060/debug/pprof/heap

# Allocs –ø—Ä–æ—Ñ–∏–ª—å (–≤—Å–µ –∞–ª–ª–æ–∫–∞—Ü–∏–∏)
go tool pprof http://localhost:6060/debug/pprof/allocs

# –í –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–º —Ä–µ–∂–∏–º–µ:
(pprof) top           # –¢–æ–ø —Ñ—É–Ω–∫—Ü–∏–π –ø–æ –ø–∞–º—è—Ç–∏
(pprof) list funcName # –ò—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ —Ñ—É–Ω–∫—Ü–∏–∏ —Å –∞–Ω–Ω–æ—Ç–∞—Ü–∏—è–º–∏
(pprof) web           # –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä–∞—Ñ–∞ (—Ç—Ä–µ–±—É–µ—Ç graphviz)

# –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–≤—É—Ö –ø—Ä–æ—Ñ–∏–ª–µ–π:
go tool pprof -base=old.prof new.prof
```

### GODEBUG –¥–ª—è GC —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏

```bash
# –í—ã–≤–æ–¥ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫–∞–∂–¥–æ–º GC
GODEBUG=gctrace=1 go run main.go

# –ü—Ä–∏–º–µ—Ä –≤—ã–≤–æ–¥–∞:
# gc 1 @0.001s 0%: 0.018+0.23+0.004 ms clock, 0.15+0.083/0.19/0.14+0.037 ms cpu, 4->4->0 MB, 5 MB goal, 8 P
#
# –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞:
# gc 1         - –Ω–æ–º–µ—Ä GC
# @0.001s      - –≤—Ä–µ–º—è —Å –∑–∞–ø—É—Å–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–º—ã
# 0%           - % –≤—Ä–µ–º–µ–Ω–∏ –≤ GC —Å –Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≥—Ä–∞–º–º—ã
# 0.018+0.23+0.004 ms clock - wall time (STW + mark + STW)
# 4->4->0 MB   - heap –¥–æ GC -> heap –ø–æ—Å–ª–µ mark -> live heap
# 5 MB goal    - —Ü–µ–ª–µ–≤–æ–π —Ä–∞–∑–º–µ—Ä heap –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ GC
# 8 P          - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–æ–≤ (GOMAXPROCS)

# –ë–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω—ã–π –≤—ã–≤–æ–¥:
GODEBUG=gctrace=2 go run main.go
```

### –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å C#

**C#** (Visual Studio Diagnostic Tools):
```csharp
// –í .NET –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è:
// - Visual Studio Profiler
// - dotnet-counters
// - PerfView
// - dotMemory (JetBrains)

// –ü—Ä–∏–º–µ—Ä —Å dotnet-counters:
// dotnet-counters monitor --process-id 1234

// –ú–µ—Ç—Ä–∏–∫–∏ GC:
// - Gen0/Gen1/Gen2 collections
// - Heap size
// - % Time in GC
// - Allocation rate
```

---

## –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–æ–¥ GC

### –ü—Ä–∏–Ω—Ü–∏–ø—ã –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

```go
package main

import "fmt"

// ‚ùå –ü–õ–û–•–û: –º–Ω–æ–≥–æ –º–∞–ª–µ–Ω—å–∫–∏—Ö –∞–ª–ª–æ–∫–∞—Ü–∏–π
func badStringConcat(items []string) string {
    result := ""
    for _, item := range items {
        result += item // –ö–∞–∂–¥–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è = –Ω–æ–≤–∞—è –∞–ª–ª–æ–∫–∞—Ü–∏—è
    }
    return result
}

// ‚úÖ –•–û–†–û–®–û: strings.Builder (–º–∏–Ω–∏–º—É–º –∞–ª–ª–æ–∫–∞—Ü–∏–π)
func goodStringConcat(items []string) string {
    var sb strings.Builder
    sb.Grow(len(items) * 10) // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –∞–ª–ª–æ–∫–∞—Ü–∏—è
    for _, item := range items {
        sb.WriteString(item)
    }
    return sb.String()
}

// ‚ùå –ü–õ–û–•–û: –∞–ª–ª–æ–∫–∞—Ü–∏—è –Ω–∞ –∫–∞–∂–¥–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏
func badLoop() {
    for i := 0; i < 1000; i++ {
        data := make([]int, 100) // 1000 –∞–ª–ª–æ–∫–∞—Ü–∏–π
        _ = data
    }
}

// ‚úÖ –•–û–†–û–®–û: –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±—É—Ñ–µ—Ä–∞
func goodLoop() {
    data := make([]int, 100) // –û–¥–Ω–∞ –∞–ª–ª–æ–∫–∞—Ü–∏—è
    for i := 0; i < 1000; i++ {
        // –û—á–∏—Å—Ç–∫–∞ –∏ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
        for j := range data {
            data[j] = 0
        }
        _ = data
    }
}

// ‚ùå –ü–õ–û–•–û: –≤–æ–∑–≤—Ä–∞—Ç —É–∫–∞–∑–∞—Ç–µ–ª—è –Ω–∞ –ª–æ–∫–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
func badReturn() *User {
    u := User{Name: "Alice"} // Escape –≤ heap
    return &u
}

// ‚úÖ –•–û–†–û–®–û: –≤–æ–∑–≤—Ä–∞—Ç –∑–Ω–∞—á–µ–Ω–∏—è (–µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ)
func goodReturn() User {
    return User{Name: "Alice"} // –ù–∞ —Å—Ç–µ–∫–µ (–µ—Å–ª–∏ –Ω–µ escape)
}
```

### –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –∞–ª–ª–æ–∫–∞—Ü–∏—è

```go
package main

// ‚ùå –ü–õ–û–•–û: –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–µ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–∏
func badSliceGrowth() []int {
    var result []int // cap = 0
    for i := 0; i < 10000; i++ {
        result = append(result, i) // –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–∏
    }
    return result
}

// ‚úÖ –•–û–†–û–®–û: –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –∞–ª–ª–æ–∫–∞—Ü–∏—è
func goodSliceGrowth() []int {
    result := make([]int, 0, 10000) // cap = 10000 —Å—Ä–∞–∑—É
    for i := 0; i < 10000; i++ {
        result = append(result, i) // –ë–µ–∑ —Ä–µ–∞–ª–ª–æ–∫–∞—Ü–∏–π
    }
    return result
}

// –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:
// bad:  ~100 –∞–ª–ª–æ–∫–∞—Ü–∏–π (–ø—Ä–∏ —Ä–æ—Å—Ç–µ capacity)
// good: 1 –∞–ª–ª–æ–∫–∞—Ü–∏—è
```

### –ò–∑–±–µ–≥–∞–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤ –≤ hot path

```go
package main

import "fmt"

// ‚ùå –ü–õ–û–•–û: –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –≤—ã–∑—ã–≤–∞–µ—Ç escape
func badLogging(value int) {
    fmt.Println(value) // value escape –≤ heap
}

// ‚úÖ –•–û–†–û–®–û: –ø—Ä—è–º–∞—è —Ä–∞–±–æ—Ç–∞ (–µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ)
func goodLogging(value int) {
    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
    // –ò–ª–∏ –±—É—Ñ–µ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ª–æ–≥–≥–µ—Ä
    logger.LogInt(value) // –ú–æ–∂–µ—Ç –Ω–µ –≤—ã–∑–≤–∞—Ç—å escape
}

// ‚ùå –ü–õ–û–•–û: interface{} –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ
type BadCache struct {
    data map[string]interface{} // –õ—é–±–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ ‚Üí escape
}

// ‚úÖ –•–û–†–û–®–û: –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø (–∏–ª–∏ generics –≤ Go 1.18+)
type GoodCache struct {
    data map[string]*User // –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø
}

// ‚úÖ –ï–©–ï –õ–£–ß–®–ï: generics (Go 1.18+)
type BestCache[T any] struct {
    data map[string]T
}
```

### Batch –æ–±—Ä–∞–±–æ—Ç–∫–∞

```go
package main

// ‚ùå –ü–õ–û–•–û: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ –æ–¥–Ω–æ–º—É
func badBatch(items []Item) {
    for _, item := range items {
        process(item) // –ú–Ω–æ–≥–æ syscalls / –∞–ª–ª–æ–∫–∞—Ü–∏–π
    }
}

// ‚úÖ –•–û–†–û–®–û: batch –æ–±—Ä–∞–±–æ—Ç–∫–∞
func goodBatch(items []Item) {
    const batchSize = 100
    for i := 0; i < len(items); i += batchSize {
        end := i + batchSize
        if end > len(items) {
            end = len(items)
        }
        processBatch(items[i:end]) // –ú–µ–Ω—å—à–µ overhead
    }
}
```

---

## sync.Pool –∏ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤

### –ß—Ç–æ —Ç–∞–∫–æ–µ sync.Pool

`sync.Pool` ‚Äî —ç—Ç–æ –∫—ç—à –¥–ª—è –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤, —á—Ç–æ–±—ã —Å–Ω–∏–∑–∏—Ç—å –¥–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ GC.

> üí° **–î–ª—è C# —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤**: –ê–Ω–∞–ª–æ–≥ `ArrayPool<T>` –≤ .NET, –Ω–æ –±–æ–ª–µ–µ –æ–±—â–∏–π.

### –ë–∞–∑–æ–≤–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ

```go
package main

import (
    "bytes"
    "sync"
)

var bufferPool = sync.Pool{
    New: func() interface{} {
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
        return new(bytes.Buffer)
    },
}

func processData(data []byte) []byte {
    // –ü–æ–ª—É—á–∏—Ç—å –±—É—Ñ–µ—Ä –∏–∑ –ø—É–ª–∞
    buf := bufferPool.Get().(*bytes.Buffer)
    defer func() {
        buf.Reset() // –û—á–∏—Å—Ç–∏—Ç—å –ø–µ—Ä–µ–¥ –≤–æ–∑–≤—Ä–∞—Ç–æ–º
        bufferPool.Put(buf) // –í–µ—Ä–Ω—É—Ç—å –≤ –ø—É–ª
    }()

    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±—É—Ñ–µ—Ä–∞
    buf.Write(data)
    buf.WriteString(" processed")

    // –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (buf –≤–µ—Ä–Ω–µ—Ç—Å—è –≤ –ø—É–ª)
    result := make([]byte, buf.Len())
    copy(result, buf.Bytes())
    return result
}

func main() {
    data := []byte("hello")
    result := processData(data)
    println(string(result))
}
```

### sync.Pool –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä

```go
package main

import (
    "sync"
)

type Request struct {
    ID   int
    Data []byte
}

var requestPool = sync.Pool{
    New: func() interface{} {
        return &Request{
            Data: make([]byte, 0, 1024), // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –∞–ª–ª–æ–∫–∞—Ü–∏—è
        }
    },
}

func handleRequest(id int, data []byte) {
    // –ü–æ–ª—É—á–∏—Ç—å –æ–±—ä–µ–∫—Ç –∏–∑ –ø—É–ª–∞
    req := requestPool.Get().(*Request)
    defer requestPool.Put(req)

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    req.ID = id
    req.Data = append(req.Data[:0], data...) // –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–ª–∞–π—Å–∞

    // –û–±—Ä–∞–±–æ—Ç–∫–∞
    processRequest(req)

    // –ù–ï –Ω—É–∂–Ω–æ –æ—á–∏—â–∞—Ç—å –≤—Ä—É—á–Ω—É—é - —ç—Ç–æ —Å–¥–µ–ª–∞–µ—Ç New –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
}

func processRequest(req *Request) {
    // –í–∞—à–∞ –ª–æ–≥–∏–∫–∞
}
```

### –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å C#

**C#** (ArrayPool):
```csharp
using System.Buffers;

public class Example
{
    private static ArrayPool<byte> pool = ArrayPool<byte>.Shared;

    public void ProcessData(byte[] data)
    {
        // –ê—Ä–µ–Ω–¥–∞ –º–∞—Å—Å–∏–≤–∞ –∏–∑ –ø—É–ª–∞
        byte[] buffer = pool.Rent(1024);
        try
        {
            // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ buffer
            Array.Copy(data, buffer, data.Length);
            // ...
        }
        finally
        {
            // –í–æ–∑–≤—Ä–∞—Ç –≤ –ø—É–ª
            pool.Return(buffer, clearArray: true);
        }
    }
}

// .NET —Ç–∞–∫–∂–µ –∏–º–µ–µ—Ç MemoryPool<T> –¥–ª—è –±–æ–ª–µ–µ –æ–±—â–∏—Ö —Å–ª—É—á–∞–µ–≤
```

### –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å sync.Pool

‚úÖ **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ sync.Pool**:
- –í—Ä–µ–º–µ–Ω–Ω—ã–µ –±—É—Ñ–µ—Ä—ã (bytes.Buffer, strings.Builder)
- –ß–∞—Å—Ç–æ —Å–æ–∑–¥–∞–≤–∞–µ–º—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –≤ hot path
- –ë–æ–ª—å—à–∏–µ –æ–±—ä–µ–∫—Ç—ã (> 1 KB), –∫–æ—Ç–æ—Ä—ã–µ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è

‚ùå **–ù–ï –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ sync.Pool**:
- –î–ª—è –¥–æ–ª–≥–æ–∂–∏–≤—É—â–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤
- –î–ª—è –º–∞–ª–µ–Ω—å–∫–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤ (< 100 bytes)
- –ö–æ–≥–¥–∞ –æ–±—ä–µ–∫—Ç–æ–≤ —Å–æ–∑–¥–∞–µ—Ç—Å—è –º–∞–ª–æ

### –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –ø—Ä–∏–º–µ—Ä: HTTP handler —Å sync.Pool

```go
package main

import (
    "encoding/json"
    "net/http"
    "sync"
)

type Response struct {
    Status string `json:"status"`
    Data   []byte `json:"data"`
}

var responsePool = sync.Pool{
    New: func() interface{} {
        return &Response{
            Data: make([]byte, 0, 1024),
        }
    },
}

func handler(w http.ResponseWriter, r *http.Request) {
    // –ü–æ–ª—É—á–∏—Ç—å Response –∏–∑ –ø—É–ª–∞
    resp := responsePool.Get().(*Response)
    defer responsePool.Put(resp)

    // –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è
    resp.Status = ""
    resp.Data = resp.Data[:0]

    // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ
    resp.Status = "ok"
    resp.Data = append(resp.Data, []byte("hello world")...)

    // –û—Ç–ø—Ä–∞–≤–∫–∞ (JSON encoder —Å–∞–º –∞–ª–ª–æ—Ü–∏—Ä—É–µ—Ç –±—É—Ñ–µ—Ä)
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(resp)
}

func main() {
    http.HandleFunc("/", handler)
    http.ListenAndServe(":8080", nil)
}
```

### –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è sync.Pool

‚ö†Ô∏è **–í–∞–∂–Ω–æ**:
- Pool –º–æ–∂–µ—Ç –±—ã—Ç—å **–æ—á–∏—â–µ–Ω GC** –≤ –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç
- **–ù–ï –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç—Å—è**, —á—Ç–æ –æ–±—ä–µ–∫—Ç –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –≤ –ø—É–ª–µ
- **–ù–ï –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ** –¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤ —Å –≤–∞–∂–Ω—ã–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º
- –û–±—ä–µ–∫—Ç—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å **–±–µ–∑–æ–ø–∞—Å–Ω—ã –¥–ª—è –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è**

```go
// ‚ùå –û–ü–ê–°–ù–û: —Å–æ—Å—Ç–æ—è–Ω–∏–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ—Ç–µ—Ä—è–Ω–æ
var connectionPool = sync.Pool{
    New: func() interface{} {
        conn, _ := sql.Open("postgres", "...")
        return conn // –ü–ª–æ—Ö–æ! –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –º–æ–∂–µ—Ç –∑–∞–∫—Ä—ã—Ç—å—Å—è
    },
}

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø—É–ª—ã
// –î–ª—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π: database/sql —É–∂–µ –∏–º–µ–µ—Ç –ø—É–ª
db, _ := sql.Open("postgres", "...")
db.SetMaxIdleConns(10)
db.SetMaxOpenConns(100)
```

---

## –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ—Ä—ã

### –ü—Ä–∏–º–µ—Ä 1: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è JSON –ø–∞—Ä—Å–∏–Ω–≥–∞

**–ó–∞–¥–∞—á–∞**: –ü–∞—Ä—Å–∏—Ç—å –º–∏–ª–ª–∏–æ–Ω—ã JSON —Å–æ–æ–±—â–µ–Ω–∏–π —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º –¥–∞–≤–ª–µ–Ω–∏–µ–º –Ω–∞ GC.

**‚ùå –ù–µ–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è**:
```go
package main

import (
    "encoding/json"
    "fmt"
)

type Message struct {
    ID      int    `json:"id"`
    Content string `json:"content"`
}

func badJSONParsing(data []byte) {
    var msg Message
    json.Unmarshal(data, &msg) // –ê–ª–ª–æ–∫–∞—Ü–∏—è –∫–∞–∂–¥—ã–π —Ä–∞–∑
    fmt.Println(msg)
}

func main() {
    data := []byte(`{"id":1,"content":"hello"}`)
    for i := 0; i < 1_000_000; i++ {
        badJSONParsing(data) // 1M –∞–ª–ª–æ–∫–∞—Ü–∏–π
    }
}
```

**‚úÖ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è** (—Å sync.Pool):
```go
package main

import (
    "encoding/json"
    "fmt"
    "sync"
)

type Message struct {
    ID      int    `json:"id"`
    Content string `json:"content"`
}

var messagePool = sync.Pool{
    New: func() interface{} {
        return &Message{}
    },
}

func goodJSONParsing(data []byte) {
    msg := messagePool.Get().(*Message)
    defer messagePool.Put(msg)

    // –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è
    msg.ID = 0
    msg.Content = ""

    json.Unmarshal(data, msg)
    fmt.Println(msg)
}

func main() {
    data := []byte(`{"id":1,"content":"hello"}`)
    for i := 0; i < 1_000_000; i++ {
        goodJSONParsing(data) // –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –º–µ–Ω—å—à–µ –∞–ª–ª–æ–∫–∞—Ü–∏–π
    }
}
```

**Benchmark**:
```go
package main

import (
    "encoding/json"
    "sync"
    "testing"
)

type Message struct {
    ID      int    `json:"id"`
    Content string `json:"content"`
}

var data = []byte(`{"id":1,"content":"hello"}`)

// –ë–µ–∑ pool
func BenchmarkWithoutPool(b *testing.B) {
    for i := 0; i < b.N; i++ {
        var msg Message
        json.Unmarshal(data, &msg)
    }
}

// –° pool
var messagePool = sync.Pool{
    New: func() interface{} { return &Message{} },
}

func BenchmarkWithPool(b *testing.B) {
    for i := 0; i < b.N; i++ {
        msg := messagePool.Get().(*Message)
        json.Unmarshal(data, msg)
        messagePool.Put(msg)
    }
}

// –†–µ–∑—É–ª—å—Ç–∞—Ç—ã:
// BenchmarkWithoutPool-8    500000    3000 ns/op    400 B/op    5 allocs/op
// BenchmarkWithPool-8       800000    1500 ns/op    100 B/op    2 allocs/op
//
// –ü—Ä–∏—Ä–æ—Å—Ç: 2x —Å–∫–æ—Ä–æ—Å—Ç—å, 4x –º–µ–Ω—å—à–µ –∞–ª–ª–æ–∫–∞—Ü–∏–π
```

---

### –ü—Ä–∏–º–µ—Ä 2: –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ GC –≤ production

**–ó–∞–¥–∞—á–∞**: –û—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –º–µ—Ç—Ä–∏–∫–∏ GC –∏ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤ Prometheus.

```go
package main

import (
    "runtime"
    "time"

    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    gcDuration = promauto.NewHistogram(prometheus.HistogramOpts{
        Name:    "go_gc_duration_seconds",
        Help:    "GC pause duration in seconds",
        Buckets: []float64{0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05, 0.1},
    })

    heapAlloc = promauto.NewGauge(prometheus.GaugeOpts{
        Name: "go_heap_alloc_bytes",
        Help: "Current heap allocation in bytes",
    })

    gcCount = promauto.NewCounter(prometheus.CounterOpts{
        Name: "go_gc_total",
        Help: "Total number of GC cycles",
    })
)

func monitorGC() {
    var lastNumGC uint32

    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()

    for range ticker.C {
        var m runtime.MemStats
        runtime.ReadMemStats(&m)

        // Heap allocation
        heapAlloc.Set(float64(m.Alloc))

        // GC count
        if m.NumGC > lastNumGC {
            newGCs := m.NumGC - lastNumGC
            gcCount.Add(float64(newGCs))

            // –ü–æ—Å–ª–µ–¥–Ω—è—è –ø–∞—É–∑–∞ GC
            lastPause := m.PauseNs[(m.NumGC+255)%256]
            gcDuration.Observe(float64(lastPause) / 1e9) // –í —Å–µ–∫—É–Ω–¥—ã

            lastNumGC = m.NumGC
        }
    }
}

func main() {
    go monitorGC()

    // –í–∞—à–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    select {}
}
```

---

### –ü—Ä–∏–º–µ—Ä 3: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–æ–¥ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã

**–ó–∞–¥–∞—á–∞**: –ù–∞—Å—Ç—Ä–æ–∏—Ç—å GC –¥–ª—è —Ä–∞–±–æ—Ç—ã –≤ Kubernetes pod —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–π –ø–∞–º—è—Ç—å—é.

```go
package main

import (
    "fmt"
    "os"
    "runtime"
    "runtime/debug"
    "strconv"
)

func setupGCForContainers() {
    // 1. –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ª–∏–º–∏—Ç –ø–∞–º—è—Ç–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
    memLimitStr := os.Getenv("MEMORY_LIMIT") // –ù–∞–ø—Ä–∏–º–µ—Ä, "2Gi"
    if memLimitStr != "" {
        memLimit := parseMemory(memLimitStr)

        // –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å GOMEMLIMIT = 90% –æ—Ç –ª–∏–º–∏—Ç–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        softLimit := int64(float64(memLimit) * 0.9)
        debug.SetMemoryLimit(softLimit)

        fmt.Printf("Memory limit: %d MB (soft: %d MB)\n",
            memLimit/1024/1024, softLimit/1024/1024)
    }

    // 2. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å GOGC –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç workload
    workload := os.Getenv("WORKLOAD_TYPE") // "cpu" –∏–ª–∏ "memory"
    switch workload {
    case "cpu":
        // CPU-bound: —Ä–µ–∂–µ GC, –±–æ–ª—å—à–µ –ø–∞–º—è—Ç–∏
        debug.SetGCPercent(200)
    case "memory":
        // Memory-bound: —á–∞—â–µ GC, –º–µ–Ω—å—à–µ –ø–∞–º—è—Ç–∏
        debug.SetGCPercent(50)
    default:
        // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
        debug.SetGCPercent(100)
    }

    // 3. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å GOMAXPROCS (–æ–±—ã—á–Ω–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)
    // –í –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω CPU count
    cpuLimit := os.Getenv("CPU_LIMIT") // –ù–∞–ø—Ä–∏–º–µ—Ä, "2"
    if cpuLimit != "" {
        cpus, _ := strconv.Atoi(cpuLimit)
        runtime.GOMAXPROCS(cpus)
        fmt.Printf("GOMAXPROCS: %d\n", cpus)
    }
}

func parseMemory(s string) int64 {
    // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ "2Gi", "500Mi"
    // –í production –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±–∏–±–ª–∏–æ—Ç–µ–∫—É
    if len(s) < 2 {
        return 0
    }

    unit := s[len(s)-2:]
    value, _ := strconv.ParseInt(s[:len(s)-2], 10, 64)

    switch unit {
    case "Gi":
        return value * 1024 * 1024 * 1024
    case "Mi":
        return value * 1024 * 1024
    case "Ki":
        return value * 1024
    default:
        return value
    }
}

func main() {
    setupGCForContainers()

    // –í—ã–≤–æ–¥ —Ç–µ–∫—É—â–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫
    fmt.Printf("GOGC: %d%%\n", debug.SetGCPercent(-1))
    debug.SetGCPercent(100) // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å

    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    fmt.Printf("Initial heap: %d MB\n", m.Alloc/1024/1024)
}
```

**Kubernetes ConfigMap**:
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  MEMORY_LIMIT: "2Gi"
  CPU_LIMIT: "2"
  WORKLOAD_TYPE: "cpu"
```

---

## –ß–µ–∫-–ª–∏—Å—Ç

–ü–æ—Å–ª–µ –∏–∑—É—á–µ–Ω–∏—è —ç—Ç–æ–≥–æ —Ä–∞–∑–¥–µ–ª–∞ –≤—ã –¥–æ–ª–∂–Ω—ã:

- [ ] –ü–æ–Ω–∏–º–∞—Ç—å —Ä–∞–∑–Ω–∏—Ü—É –º–µ–∂–¥—É Go GC –∏ .NET GC
- [ ] –ó–Ω–∞—Ç—å, –∫–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç tri-color mark-and-sweep
- [ ] –ü–æ–Ω–∏–º–∞—Ç—å —Ä–æ–ª—å write barriers –≤ concurrent GC
- [ ] –£–º–µ—Ç—å –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞—Ç—å GOGC –∏ GOMEMLIMIT
- [ ] –ü–æ–Ω–∏–º–∞—Ç—å escape analysis –∏ stack vs heap
- [ ] –£–º–µ—Ç—å –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞—Ç—å GC —Å –ø–æ–º–æ—â—å—é pprof
- [ ] –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å GODEBUG=gctrace –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
- [ ] –ü—Ä–∏–º–µ–Ω—è—Ç—å sync.Pool –¥–ª—è –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤
- [ ] –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥ –ø–æ–¥ GC (–∏–∑–±–µ–≥–∞—Ç—å –∞–ª–ª–æ–∫–∞—Ü–∏–π)
- [ ] –ù–∞—Å—Ç—Ä–∞–∏–≤–∞—Ç—å GC –¥–ª—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ (Kubernetes/Docker)

---

## –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏

–ü–µ—Ä–µ—Ö–æ–¥–∏—Ç–µ –∫ [2.4 –ü—Ä–∏–º–∏—Ç–∏–≤—ã —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏](./04_sync_primitives.md) ‚Äî –∏–∑—É—á–µ–Ω–∏–µ Mutex, WaitGroup, atomic –∏ –¥—Ä—É–≥–∏—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤.

---

**–í–æ–ø—Ä–æ—Å—ã?** –û—Ç–∫—Ä–æ–π issue –Ω–∞ [GitHub](https://github.com/AlexandrTolstuhin/csharp-to-go/issues)

[‚Üê –ù–∞–∑–∞–¥: 2.2 Go Runtime –∏ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫](./02_runtime_scheduler.md) | [–í–ø–µ—Ä—ë–¥: 2.4 –ü—Ä–∏–º–∏—Ç–∏–≤—ã —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ ‚Üí](./04_sync_primitives.md)
